<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Page Title</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!--link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" /-->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Site Description Here" />
<link rel="stylesheet" href="bulma.min.css">
<link rel="stylesheet" href="quill.snow.css">
<link rel="stylesheet" href="jexcel.css" type="text/css" />
<link rel="stylesheet" href="jsuites.css" type="text/css" />
<!-- Include the JS libraries -->
<script src="quill.min.js"></script>
<script src="vue.min.js"></script>
<script src="jexcel.js"></script>
<script src="jsuites.js"></script>

<style>
@font-face {
  font-family: "archivo-regular";
  src: url("/Archivo-Regular.woff");
} 

body {
 font-family: archivo-regular;
}

.ctxmenu {
  cursor: context-menu;
  position: absolute;
  z-index: 100;
}
.ctxmenu li {
  padding-left: 0.25em;
  padding-right: 0.25em;
}
.ctxmenu li:hover{
	background: #aaaaaa;
	color: #eeeeee;
}


.jexcel {
font-family: "archivo-regular",arial, sans-serif;
}
#jexcel {
 height: 65vh;
 width: 100%;
    overflow-y: scroll;
}

.brk {
  word-wrap: anywhere;
}
.mono {
font-family: monospace;
white-space: pre-wrap;
white-space: -moz-pre-wrap;
white-space: -pre-wrap;
white-space: -o-pre-wrap;
word-wrap: anywhere;
}
.ptr { cursor: pointer; }
.arrow { cursor: context-menu; }
.bold { font-weight: bold; }
.drag { cursor: move; }

.spacer5px { height: 5px; }

.sidenavbar {
 height: 75vh;
 overflow-y: scroll;
}

.tooloutput {
}
.mpprojects {
}
.fullw { width: 100%; }


.inln {
  display: inline-block;
  vertical-align: middle;
}


::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1; 
}
 
::-webkit-scrollbar-thumb {
  background: #888; 
}

::-webkit-scrollbar-thumb:hover {
  background: #555; 
}

/**********************************/
/*  draggable pane layout stuff   */
/**********************************/
#body_container {
  display: grid;
  height: 100vh;
  grid-template-columns: 1fr;
  grid-template-rows: min-content 1fr min-content;
  grid-template-areas:
        "header"
        "main"
        "footer";

}
#topnavbar {
  grid-area: header;
}
#pageFrame {
  grid-area: main;
    overflow: hidden;
}
#bottomnavbar {
  grid-area: footer;
}

#page {
  //height: 90vh;

  height: 100%;
  display: grid;
  grid-template-areas: 'left_pane dragbar right_pane';
  grid-template-rows: 10fr;
  grid-template-columns: 2fr 6px 6fr;
}

#left_pane {
 // overflow: auto;
  grid-area: left_pane;
   overflow-y: scroll;
	height: 100%;
}

#dragbar {
  background-color: #dddddd;
  grid-area: dragbar;
  cursor: ew-resize;
}

#right_pane {
  //overflow: auto;
  grid-area: right_pane;
   overflow-y: scroll;
	height: 100%;
}

#modal_div {
//	  z-index: 100;
//	position: absolute;
//	top: 0px;
//	left: 0px;
}


</style>


    <!-- item template -->
    <template type="text/x-template" id="item-template">
      <li>

        <div :style="[{textIndent: getIndent},isCurrentlySelected() ? {'background-color' : '#CCEEFF'} : {}]" @contextmenu="showCtxMenu($event,item.uid)" 
			draggable @dragstart="startDrag($event,item.uid)" @drop='onDrop($event)' @dragover.prevent @dragenter.prevent >
		<span><!--img v-bind:class="getIcon()"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+getIcon()"></use></svg></span>
		<span v-bind:style="[item.isViewed ? {} : {'font-weight': 'bold'}]" class="arrow" @click="viewNode($event,item.uid)">{{ item.l }}</span><!--{{ name() }}-->
		<span v-if="item.out && item.out.length" @click="toggle(item.uid)">
		<span v-if="isOpen"><!--img class="ico-sqminus"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-sqminus"></use></svg></span>
		<span v-else><!--img class="ico-sqplus"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-sqplus"></span>
		</span>
        </div>
        <!--ul v-show="isOpen" v-if="hasChildren"-->
        <ul v-show="isOpen" v-if="item.outrefs && item.outrefs.length">
          <tree-item
		    :ref="item.uid"
            v-for="(child, index) in item.outrefs"
            :key="item.uid"
            :item="child"
			:depth="depth+1"
            @make-folder="$emit('make-folder', $event)"
            @add-item="$emit('add-item', $event)"
          ></tree-item>
        </ul>
      </li>
    </template>

</head>
<body onresize="ResetColumnSizes()">

<svg style="display: none;"><defs>
    <g id="shape-icon-2" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
	  <circle cx='12' cy='12' r='10'></circle><line x1='15' y1='9' x2='9' y2='15'></line><line x1='9' y1='9' x2='15' y2='15'></line>
    </g>
</defs></svg>

<svg style="display: none;"><defs>
    <g id="ico-edit" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M12 20h9'></path><path d='M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-del" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><line x1='15' y1='9' x2='9' y2='15'></line><line x1='9' y1='9' x2='15' y2='15'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-new" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'></path><polyline points='14 2 14 8 20 8'></polyline><line x1='12' y1='18' x2='12' y2='12'></line><line x1='9' y1='15' x2='15' y2='15'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-left" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><polyline points='12 8 8 12 12 16'></polyline><line x1='16' y1='12' x2='8' y2='12'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-sqminus" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<rect x='3' y='3' width='18' height='18' rx='2' ry='2'></rect><line x1='8' y1='12' x2='16' y2='12'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-sqplus" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<rect x='3' y='3' width='18' height='18' rx='2' ry='2'></rect><line x1='12' y1='8' x2='12' y2='16'></line><line x1='8' y1='12' x2='16' y2='12'></line>
    </g>
</defs></svg>



<svg style="display: none;"><defs>
    <g id="ico-miscfile" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z'></path><polyline points='13 2 13 9 20 9'></polyline>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-folder" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-move" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<polyline points='5 9 2 12 5 15'></polyline><polyline points='9 5 12 2 15 5'></polyline><polyline points='15 19 12 22 9 19'></polyline><polyline points='19 9 22 12 19 15'></polyline><line x1='2' y1='12' x2='22' y2='12'></line><line x1='12' y1='2' x2='12' y2='22'></line>
    </g>
</defs></svg>



<svg style="display: none;"><defs>
    <g id="ico-copy" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<rect x='9' y='9' width='13' height='13' rx='2' ry='2'></rect><path d='M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-user" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2'></path><circle cx='12' cy='7' r='4'></circle>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-book" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z'></path><path d='M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-host" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<line x1='22' y1='12' x2='2' y2='12'></line><path d='M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z'></path><line x1='6' y1='16' x2='6.01' y2='16'></line><line x1='10' y1='16' x2='10.01' y2='16'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-hash" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<line x1='4' y1='9' x2='20' y2='9'></line><line x1='4' y1='15' x2='20' y2='15'></line><line x1='10' y1='3' x2='8' y2='21'></line><line x1='16' y1='3' x2='14' y2='21'></line>
    </g>
</defs></svg>



<svg style="display: none;"><defs>
    <g id="ico-code" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<polyline points='16 18 22 12 16 6'></polyline><polyline points='8 6 2 12 8 18'></polyline>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-img" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<rect x='3' y='3' width='18' height='18' rx='2' ry='2'></rect><circle cx='8.5' cy='8.5' r='1.5'></circle><polyline points='21 15 16 10 5 21'></polyline>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-note" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7'></path><path d='M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-table" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<rect x='3' y='3' width='7' height='7'></rect><rect x='14' y='3' width='7' height='7'></rect><rect x='14' y='14' width='7' height='7'></rect><rect x='3' y='14' width='7' height='7'></rect>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-info" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><line x1='12' y1='16' x2='12' y2='12'></line><line x1='12' y1='8' x2='12.01' y2='8'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-tag" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z'></path><line x1='7' y1='7' x2='7.01' y2='7'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-report" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<line x1='8' y1='6' x2='21' y2='6'></line><line x1='8' y1='12' x2='21' y2='12'></line><line x1='8' y1='18' x2='21' y2='18'></line><line x1='3' y1='6' x2='3.01' y2='6'></line><line x1='3' y1='12' x2='3.01' y2='12'></line><line x1='3' y1='18' x2='3.01' y2='18'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-mark" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z'></path>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-send" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<line x1='22' y1='2' x2='11' y2='13'></line><polygon points='22 2 15 22 11 13 2 9 22 2'></polygon>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-left-arr" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><polyline points='12 8 8 12 12 16'></polyline><line x1='16' y1='12' x2='8' y2='12'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-right-arr" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><polyline points='12 16 16 12 12 8'></polyline><line x1='8' y1='12' x2='16' y2='12'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-left-arr-dis" viewBox='0 0 24 24' fill='none' stroke='LightGrey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><polyline points='12 8 8 12 12 16'></polyline><line x1='16' y1='12' x2='8' y2='12'></line>
    </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-right-arr-dis" viewBox='0 0 24 24' fill='none' stroke='LightGrey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><polyline points='12 16 16 12 12 8'></polyline><line x1='8' y1='12' x2='16' y2='12'></line>
    </g>
</defs></svg>


<!--
<svg style="display: none;"><defs>
    <g id="ico-load">
<g><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#000"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(45 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(90 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(135 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#bebebe" transform="rotate(180 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#979797" transform="rotate(225 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#6e6e6e" transform="rotate(270 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#3c3c3c" transform="rotate(315 64 64)"/><animateTransform attributeName="transform" type="rotate" values="0 64 64;45 64 64;90 64 64;135 64 64;180 64 64;225 64 64;270 64 64;315 64 64" calcMode="discrete" dur="720ms" repeatCount="indefinite"></animateTransform></g><g><circle fill="#000" cx="63.66" cy="63.16" r="12"/><animate attributeName="opacity" dur="720ms" begin="0s" repeatCount="indefinite" keyTimes="0;0.5;1" values="1;0;1"/></g>
   </g>
</defs></svg>


<svg style="display: none;"><defs>
    <g id="ico-logo" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><line x1='14.31' y1='8' x2='20.05' y2='17.94'></line><line x1='9.69' y1='8' x2='21.17' y2='8'></line><line x1='7.38' y1='12' x2='13.12' y2='2.06'></line><line x1='9.69' y1='16' x2='3.95' y2='6.06'></line><line x1='14.31' y1='16' x2='2.83' y2='16'></line><line x1='16.62' y1='12' x2='10.88' y2='21.94'></line>
   </g>
</defs></svg>
-->

<svg style="display: none;"><defs>
    <g id="ico-upload" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4'></path><polyline points='17 8 12 3 7 8'></polyline><line x1='12' y1='3' x2='12' y2='15'></line>
   </g>
</defs></svg>

<svg style="display: none;"><defs>
    <g id="ico-file2" viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<path d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'></path><polyline points='14 2 14 8 20 8'></polyline><line x1='16' y1='13' x2='8' y2='13'></line><line x1='16' y1='17' x2='8' y2='17'></line><polyline points='10 9 9 9 8 9'></polyline>
   </g>
</defs></svg>



<div id="body_container" onclick="HideContextMenu()">


 <div id="ctxmenu-div" class="ctxmenu box has-background-light p-2" style="display: none">
   <ul id="v_ctxmenu">
    <li><b>Actions</b></li>
	<li v-for="optM in vdata.ctxmenuData.mainOptions" @click="ctxmenuAction($event,optM,vdata.ctxmenuData.uid)"><!--img class="ico-edit"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-edit"></use></svg>{{optM}}</li>
	<li v-for="optA in vdata.ctxmenuData.addOptions" @click="ctxmenuAction($event,optA,vdata.ctxmenuData.uid)"><!--img class="ico-new"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-new"></use></svg>{{optA.replace('+','add ')}}</li>
   </ul>
</div>


<!-- top nav bar -->
<nav id="topnavbar" class="level box p-1">

  <!-- Left side -->
  <div class="level-left ml-3">
    <div class="level-item mr-1">
	<!--img id="id_logo" class="ico-logo" onClick=""--><!--svg id="id_logo" class="inln" width='2em' height='2em' viewBox='0 0 24 24'><use href="#ico-logo"></use></svg-->

<svg id="ico-logo" class="inln" width='2em' height='2em' viewBox='0 0 24 24'>
    <g viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>
<circle cx='12' cy='12' r='10'></circle><line x1='14.31' y1='8' x2='20.05' y2='17.94'></line><line x1='9.69' y1='8' x2='21.17' y2='8'></line><line x1='7.38' y1='12' x2='13.12' y2='2.06'></line><line x1='9.69' y1='16' x2='3.95' y2='6.06'></line><line x1='14.31' y1='16' x2='2.83' y2='16'></line><line x1='16.62' y1='12' x2='10.88' y2='21.94'></line>
   </g>
</svg>

<svg id="ico-load" class="inln"  width='2em' height='2em' viewBox='0 0 128 128' style="display: none;">
<g><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#000"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(45 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(90 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#e1e1e1" transform="rotate(135 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#bebebe" transform="rotate(180 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#979797" transform="rotate(225 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#6e6e6e" transform="rotate(270 64 64)"/><path d="M71 39.2V.4a63.6 63.6 0 0 1 33.96 14.57L77.68 42.24a25.53 25.53 0 0 0-6.7-3.03z" fill="#3c3c3c" transform="rotate(315 64 64)"/><animateTransform attributeName="transform" type="rotate" values="0 64 64;45 64 64;90 64 64;135 64 64;180 64 64;225 64 64;270 64 64;315 64 64" calcMode="discrete" dur="720ms" repeatCount="indefinite"></animateTransform></g><g><circle fill="#000" cx="63.66" cy="63.16" r="12"/><animate attributeName="opacity" dur="720ms" begin="0s" repeatCount="indefinite" keyTimes="0;0.5;1" values="1;0;1"/></g>
</svg>


    </div>
    <div class="level-item">
      <p class="subtitle is-3 ptr" onClick="">
        <strong>collablio</strong>
      </p>
    </div>
    <div id="v_topsearch" class="level-item">
      <div class="field has-addons">
        <p class="control">
          <input class="input is-small" type="text" style="width: 30vw;" v-model="query" :placeholder="'Search within '+v.node.l">
        </p>
        <p class="control">
          <button class="button is-small" @click="vDoSearch()">
            Search
          </button>
        </p>
      </div>
    </div>
  </div>

  <!-- Right side -->
  <div id="v_topnav" class="level-right">
    <p class="level-item"><strong>{{v.node.l}}</strong></p>
    <p class="level-item is-size-3 ptr" @click="vNavBack()"><!--img style="stroke: blue;" v-bind:class="iconBack"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+iconBack"></use></svg></p>
    <p class="level-item is-size-3 ptr" @click="vNavFwd()"><!--img v-bind:class="iconFwd"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+iconFwd"></use></svg></p>

    <p class="level-item"  @click="vSync()"><a class="button is-small">Sync</a></p>
    <p class="level-item"><a @click="" class="button is-success is-small">Tasks</a></p>
  </div>

</nav>

<!-- columns view (tree + main panes) -->

<div id="pageFrame">
  <div id="page" onmouseup="EndDrag()" onmousemove="OnDrag(event)">

    <div id="left_pane" class="pl-3 pr-3">
 	  <div id="tree_pane" class="">
		<ul id="v_tree_pane">
		  <ctxmenu></ctxmenu>
		  <tree-item
		    :ref="treeData.root.uid"
			:depth="0"
			:item="treeData.root"
			@make-folder="makeFolder"
			@add-item="addItem"
		  ></tree-item>
		</ul>
	  </div>
    </div>
	
    <div id="dragbar" onmousedown="StartLeftDrag()"></div>

    <div id="right_pane" class="pl-3 pr-3">
	 

		<div id="othermain_search" class="box content" style="display: none">
		<!--////VueBinding////-->
			<div id="v_othermain_search">
				<h2>Search Results</h2>
				<div class="mpprojects">
				  
				  <div class="box">
					<div class="box">
						<p>{{v.config.results.nodes.length}} Results were located under {{v.config.results.nodelabel}} for "{{v.config.results.query}}"</p>
					</div>
					<div v-for="(result, index) in v.config.results.nodes" class="mb-1">
					<!-- TODO: allow cloning of items but need to fetch attachment body if it hasnt been populated yet -->
					<!-- the same issue does not occur when cloning from the view or edit pane because the body has been loaded -->
					<!-- maybe add a hasAttachmentBody field to the typeConfig?? -->

						<div class="columns is-vcentered">
							<div class="column is-4 ptr pl-2" @click="viewNode($event,result.uid)"><!--img v-bind:class="getTypeIcon(result)"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+getTypeIcon(result)"></use></svg> {{result.l}}</div>
							<div class="column is-8 ptr pl-5" @click="viewNode($event,result.uid)">{{result.d}}</div>
						</div>

					</div>

				  </div>

				</div>
			</div>
		</div>

	 
		<div id="view_default" class="box content" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_default">
				<h2><!--img v-bind:class="getTypeIcon(v.config.nodeinfo)"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+getTypeIcon(v.config.nodeinfo)"></use></svg> {{v.config.nodeinfo.l}}</h2>
				<div class="mpprojects">
				  <div class="box">
					<p class="subtitle">Detail</p>
					<div class="mono">{{v.config.nodeinfo.d}}</div>
				  </div>
				  <div class="box">
					<p class="subtitle">Custom Data Field</p>
					<div class="mono">{{v.config.nodeinfo.c}}</div>
				  </div>
				  <div class="box"  @drop='onDrop($event)' @dragover.prevent @dragenter.prevent>
					<p class="subtitle">List of Child Items</p>
					<div v-for="(child, index) in v.config.nodeinfo.outrefs" class="mb-1">
					<!-- TODO: allow cloning of items but need to fetch attachment body if it hasnt been populated yet -->
					<!-- the same issue does not occur when cloning from the view or edit pane because the body has been loaded -->
					<!-- maybe add a hasAttachmentBody field to the typeConfig?? -->

					<div class="columns is-vcentered">
						<div class="column is-1"><span class="button is-info is-small drag" draggable @dragstart="startDrag($event,child.uid)">&#10021; Move</span></div>
						<div class="column is-3 ptr pl-2" @click="viewNode($event,child.uid)"><!--img v-bind:class="getTypeIcon(child)"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use :href="'#'+getTypeIcon(child)"></use></svg> {{child.l}}</div>
						<div class="column is-8 ptr pl-5" @click="viewNode($event,child.uid)">{{child.d}}</div>
					</div>

					</div>
					<div class="box" v-if="v.config.nodeinfo.out.length > 0 && v.config.nodeinfo.outrefs.length < 1">
						<a class="button is-info" @click="loadChildren(v.config.nodeinfo.uid)">Show Child Items</a>
					</div>
					<div class="box" v-if="v.config.nodeinfo.out.length < 1">
						<p>No Child Items</p>
					</div>
				  </div>

				</div>
			</div>
		</div>
	 
		<div id="view_textbody" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_textbody">
				<h2>{{v.config.nodeinfo.l}}</h2>
				  <div class="tooloutput"><div class="mono">{{v.config.nodeinfo.x}}</div></div>
				
			</div>
		</div>

		<div id="view_editor" style="display: none">
			<div class="columns is-vcentered">				
				<div class="column">
				  <div class="field">
					<p class="control">
					  <input id="editor_title" class="input titleedit" type="text" placeholder="Enter a Note Title">
					</p>
				  </div>
				</div>
				<div class="column is-one-third has-text-left">
				  <span><a class="button is-primary" id="toggleEditing" onclick="toggleQuill()">Edit</a></span>
				  <span><div class="button drag is-success" id="v_all_editor" draggable @dragstart="startDrag($event)">Clone</div></span>
				</div>	
			</div>						
			<div id="editor" style="height: 65vh;"></div> 
		</div>
	 
	 
	 
		<div id="view_table" style="display: none">
				  <div class="columns is-vcentered">				
					<div class="column">
					  <div class="field">
						<p class="control">
						  <input id="table_title" class="input titleedit" type="text" placeholder="Enter a Note Title">
						</p>
					  </div>
					</div>
					
					<div class="column is-one-third has-text-left">
					  <span><a class="button is-primary" id="toggleEditingTable" onclick="toggleJexcel()">Edit</a></span>
					  <span><div class="button drag is-success" id="v_all_table" draggable @dragstart="startDrag($event)">Clone</div></span>
					</div>
							
				  </div>
		
			<div id="jexcel"></div> 
		</div>	 
	 
	 
	 
		<div id="main_pane_testform" style="display: none">
		</div><!-- end main_pane -->
	 
	 
		<div id="edit_default" style="display: none">
		<!--////VueBinding////-->
		 <div id="v_edit_default">
			<h1 class="title">Edit {{getTypeName(v.config.nodeinfo.uid)}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Label</label><div class="control"><input class="input" type="text" placeholder="Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>

				<div class="field">
				  <label class="label">Short Description</label><div class="control"><input class="input is-success" type="text" placeholder="Description" v-model="v.config.nodeinfo.d"></div>
				</div>

				<div class="field">
				  <label class="label">Custom Data Field</label><div class="control"><textarea class="textarea" placeholder="notes area" v-model="v.config.nodeinfo.c"></textarea></div>
				</div>

				<div class="field is-grouped">
				  <div class="control"><button class="button is-link" @click="vSubmit()">Save</button></div>
				  <div class="control"><button class="button is-link is-light">Cancel</button></div>
				</div>
				
			  </div>
			</div>
		 </div>
		</div><!-- end main_pane -->



	 
		<div id="view_download" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_download">
				<h2>File: {{v.config.nodeinfo.l}}</h2>
				<div class="tooloutput">
					<div v-if="v.config.nodeinfo.d.startsWith('image/')">
					<img :src="'/download/'+v.config.nodeinfo.uid" id="imgview" class="ptr" @click="vOpenNewWindow('/download/'+v.config.nodeinfo.uid)">
					</div>
					<div v-else>
					<h3>Download</h3>
					<p>
					<span class="ptr" @click="vOpenNewWindow('/download/'+v.config.nodeinfo.uid)">
					<!--img class="ico-file2"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-file2"></use></svg><br>
					{{v.config.nodeinfo.l}}</span>
					<br>({{v.config.nodeinfo.d}})
					</p>
					</div>
				</div>
			</div>
		</div>

	 
		<div id="view_image" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_image">
				<h2>{{v.config.nodeinfo.l}}</h2>
				<div class="tooloutput">
					<div v-if="v.config.nodeinfo.d.startsWith('image/')">
					<img :src="'/download/'+v.config.nodeinfo.uid" id="imgview" class="ptr" onclick="toggleImgFullscreen()">
					</div>
					<div v-else>
					<h3>Download</h3>
					<p>
					<a :href="'/download/'+v.config.nodeinfo.uid">
					<!--img class="ico-file2"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-file2"></use></svg><br>
					{{v.config.nodeinfo.l}}</a>
					<br>({{v.config.nodeinfo.d}})
					</p>
					</div>
				</div>
			</div>
		</div>
		
		
		
    </div><!--end right_pane-->

  </div>
</div>





<div id="graph_layout"></div>

<!--footer-->
<nav id="bottomnavbar" class="level box p-1">

  <!-- Left side -->
  <div class="level-left ml-3">
    <div class="level-item mr-1">
		Placeholder
    </div>
    <div class="level-item">
      <p class="subtitle is-7 ptr" onClick="">
        <strong>Test</strong>
      </p>
    </div>
    <div class="level-item">
    </div>
  </div>

  <!-- Right side -->
  <div id="v_bottomnav" class="level-right">
    <p class="level-item"><strong>{{v.node.l}}</strong></p>
  </div>

</nav>






</div><!--body_container-->


<!--Modal Display-->
<div id="modal_div" class="modal">
  <div class="modal-background"></div>
  <div class="modal-card">


    <!--div for modal pane-->
	<div id="add_fileupload" style="display: none">
	 <div id="v_add_fileupload"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Upload a File Attachment</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
			<div class="file has-name">
			  <label class="file-label">
				<input class="file-input" type="file" id="at_file" @change="vUpdateFileName()" name="upload">
				<span class="file-cta">
				  <span class="file-icon">
					<!--img class="ico-upload"--><svg class="inln" width='1em' height='1em' viewBox='0 0 24 24'><use href="#ico-upload"></use></svg>
				  </span>
				  <span class="file-label">
					Choose a fileâ€¦
				  </span>
				</span>
				<span class="file-name" id="at_file_name">
				  {{filename}}
				</span>
			  </label>
			</div>

		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Save changes</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->




    <!--div for modal pane-->
	<div id="add_default" style="display: block">
	 <div id="v_add_default"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Add New {{v.config.nodeinfo.ty}}</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
	  		<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">{{v.config.nodeinfo.ty}} Label</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>

				<div class="field">
				  <label class="label">Short Description</label><div class="control"><input class="input is-success" type="text" placeholder="Client Full Name or Description" v-model="v.config.nodeinfo.d"></div>
				</div>

				<div class="field">
				  <label class="label">Custom Data Field</label><div class="control"><textarea class="textarea" placeholder="Client notes area" v-model="v.config.nodeinfo.c"></textarea></div>
				</div>

			  </div>
			</div>
		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Add {{v.config.nodeinfo.ty}}</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->	




    <!--div for modal pane-->
	<div id="add_editor" style="display: block">
	 <div id="v_add_editor"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Enter a Title for New Note</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
	  		<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Note Name</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>
				
			  </div>
			</div>
		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Create Note</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->	



    <!--div for modal pane-->
	<div id="add_table" style="display: block">
	 <div id="v_add_table"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Enter a Title for New Table</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
	  		<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Table Name</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>
				
			  </div>
			</div>
		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Create Table</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->	



	
  <button onclick="toggleModal()" class="modal-close is-large" aria-label="close"></button>
 </div>
</div><!--end modal div-->	


<div id="testdiv" style="background-color: green; width: 50%; height: 50%; position: absolute; top: 100px; left: 100px; display: none">
test
</div>

<script>
// script begin --------------------------------------------------------------------------------------------------------

function toggleImgFullscreen() {
  let elem = document.getElementById("imgview");

  if (!document.fullscreenElement) {
    elem.requestFullscreen().catch(err => {
      alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
    });
  } else {
    document.exitFullscreen();
  }
}

function openNewWindow(url) {
  var win = window.open(url, '_blank');
  win.focus();
}

function notification(msg) {
	alert(msg);
}
// Quill editor --------------------------------------------------------------------------------------------------------

var toolbarOptions = [
  ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
  ['blockquote', 'code-block'],

  [{ 'header': 1 }, { 'header': 2 }],               // custom button values
  [{ 'list': 'ordered'}, { 'list': 'bullet' }],
  [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript
  [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent
  [{ 'direction': 'rtl' }],                         // text direction

  [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
  [{ 'header': [1, 2, 3, 4, 5, 6, false] }],

  [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
  [{ 'font': [] }],
  [{ 'align': [] }],
  ['image'],
  ['video'],
  ['clean']                                         // remove formatting button
];

var quill = new Quill('#editor', {
  modules: {
    toolbar: toolbarOptions
  },
  theme: 'snow'
});
quill.disable();

//Instead of this maybe use: event.dataTransfer.setData and getData?
var quillGlobal = { CurrentUid: '' };

function toggleQuill()
{
	let isEnabled = quill.isEnabled();
	if(isEnabled)
		_panesIndex['edit']['editor'].onAfterSubmit();
	else
		v_action_funcs['edit'](quillGlobal.CurrentUid);
}

function populateQuill(nodeinfo)
{
	// serializedDelta can be stored in persistent storage or sent in a message etc.
	let serialisedDeltas = nodeinfo[PROP_TEXTDATA] ||  "{}";
	quill.setContents(JSON.parse(serialisedDeltas));	
	let edtitle = document.getElementById('editor_title');
	edtitle.value = nodeinfo[PROP_LABEL];
}

function getQuillEdits(nodeinfo)
{
	let edtitle = document.getElementById('editor_title');
	let deltas = quill.getContents();
	nodeinfo[PROP_TEXTDATA] = JSON.stringify(deltas);
	nodeinfo[PROP_LABEL] = edtitle.value;
	nodeinfo[PROP_DETAIL] = 'Note';
}

function setQuillVisualState(status)
{
	let edbutton = document.getElementById('toggleEditing');
	let edtitle = document.getElementById('editor_title');

	if(status == 'enable') {
		quill.enable();
		edtitle.readOnly = false;
		edbutton.innerText = "Save";
	}
	else {
		quill.disable();
		edtitle.readOnly = true;
		edbutton.innerText = "Edit";
	}

}

// jexcel ------------------------------------------------------------

var jexcelGlobal = { CurrentUid: '' };

var j_initial_cols = [{type: 'text', title:'A',width:100},{type: 'text', title:'B',width:100}] ;
var j_initial_data = [{0:'',1:''},{0:'',1:''}];

var j = jexcel(document.getElementById('jexcel'), {
 data: j_initial_data,
 columns: j_initial_cols
}
);

var j_isEnabled = false;
function toggleJexcel()
{
	if(j_isEnabled)
		_panesIndex['edit']['table'].onAfterSubmit();
	else
		v_action_funcs['edit'](jexcelGlobal.CurrentUid);
	j_isEnabled = !j_isEnabled;
}

function setJexcelReadonly(readonly = true)
{
	let jconf = j.getConfig();
	jconf.columns.forEach(column => column.readOnly = readonly);
	//reload to show updated state
	j.setData(null);
}

function populateJexcel(nodeinfo)
{
	let serialisedData = nodeinfo[PROP_TEXTDATA] ||  '{"jsondata":null,"jsoncols":null}';
console.log('Jexcel serialisedData',serialisedData);
	let jdata = JSON.parse(serialisedData);
	let rowdata = JSON.parse(jdata.jsondata) || j_initial_data;
	let coldata = JSON.parse(jdata.jsoncols) || j_initial_cols;

	j.destroy();
	j = jexcel(document.getElementById('jexcel'), {
        data: rowdata,
        columns: coldata
    });

	let edtitle = document.getElementById('table_title');
	edtitle.value = nodeinfo[PROP_LABEL];
}

function getJexcelEdits(nodeinfo)
{
	let edtitle = document.getElementById('table_title');
	let jdata = {};
	jdata.jsondata = JSON.stringify(j.getConfig().data);
	jdata.jsoncols = JSON.stringify(j.getConfig().columns);
	//yep, they're serialised json inside serialised json
	nodeinfo[PROP_TEXTDATA] = JSON.stringify(jdata);
	nodeinfo[PROP_LABEL] = edtitle.value;
	nodeinfo[PROP_DETAIL] = 'Table';
}

function setJexcelVisualState(status)
{
	let edbutton = document.getElementById('toggleEditingTable');
	let edtitle = document.getElementById('table_title');

	if(status == 'enable') {
		setJexcelReadonly(false);
		edtitle.readOnly = false;
		edbutton.innerText = "Save";
	}
	else {
		setJexcelReadonly(true);
		edtitle.readOnly = true;
		edbutton.innerText = "Edit";
	}

}
// data stores ------------------------------------------------------------
const TYPE_ROOT = "__ROOT__";
const PROP_UID = "uid";
const PROP_TYPE = "ty";
const PROP_LABEL = "l";
const PROP_DETAIL = "d";
const PROP_TEXTDATA = "x";
const PROP_CUSTOM = "c";
const PROP_TIME = "t";
const PROP_LASTMOD = "m";
const PROP_BINARYDATA = "b";
const PROP_EDITING = "e";
const PROP_PARENTLIST = "in";
const PROP_CHILDLIST = "out";
const PROP_RELATIONS = "lnk";
const PROP_PARENTREFS = "inrefs";
const PROP_CHILDREFS = "outrefs";
const PROP_VUEREF = 'vueref';

function emptyNode(_uid = '', type = '') { 

	let node = {};
	node[PROP_UID] = _uid;
	node[PROP_TYPE] = type;
	node[PROP_LABEL] = '';
	node[PROP_DETAIL] = '';
	node[PROP_TEXTDATA] = '';
	node[PROP_CUSTOM] = '';
	node[PROP_TIME] = '';
	node[PROP_LASTMOD] = '';
	node[PROP_BINARYDATA] = '';
	node[PROP_EDITING] = '';
	node[PROP_PARENTLIST] = [];
	node[PROP_CHILDLIST] = [];
	node[PROP_PARENTREFS] = [];
	node[PROP_CHILDREFS] = [];
	node[PROP_RELATIONS] = [];
	node.hasChanged = false;
	node.isViewed = false;
	node.isOpen = false;
	return node;
};

var _root = emptyNode('.',TYPE_ROOT);
var _index = {};
var G = { root : _root , ctxmenuData: emptyCtxMenuData()};

_index[_root.uid] = _root;
_root.l = "All Categories";


var _defaultPaneConfigs = {
	//main_pane is the target for these:
	view: {
		//key : function to return config obj
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible
				label: { visible: true, name: "Label" },
				detail: { visible: true, name: "Detail" },
				custom: { visible: true, name: "Custom Data" },
				textdata: { visible: true, name: "Text Data" },
				eventtime: { visible: true, name: "Event Time" },
				title: '',
			};
		},
	},
	edit: {
		//key : DOMelementID
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible, editable, and its label
				label: { visible: true, editable: true, name: "Label", required: true },
				detail: { visible: true, editable: true, name: "Detail", required: true },
				custom: { visible: true, editable: true, name: "Custom Data", required: false },
				textdata: { visible: true, editable: true, name: "Text Data", required: false },
				eventtime: { visible: true, editable: true, name: "Event Time", required: false },
				title: '',
			};
		},
	},
	othermain: {
		//key : function to return config obj
		"search" : function() {
			return {
				title: '',
				results: { 
					nodes: [emptyNode('0x0',TYPE_ROOT)],
					nodelabel: '<blank>',
					query: '<blank>',
				}
			};
		},
	},
	//modal is the target for these:
	add: {
		//key : DOMelementID
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible, editable, and its label
				label: { visible: true, editable: true, name: "Label", required: true },
				detail: { visible: true, editable: true, name: "Detail", required: true },
				custom: { visible: true, editable: true, name: "Custom Data", required: false },
				textdata: { visible: true, editable: true, name: "Text Data", required: false },
				eventtime: { visible: true, editable: true, name: "Event Time", required: false },
				title: '',
			};
		},
	},
	moveparent:  {
		//key : DOMelementID
		"default" : function() { return {} },
	},
	movechildren: {
		//key : DOMelementID
		"default" : function() { return {} },
	}
};

function getDefaultConfig(panetype, subtype = 'default')
{
	let conf = _defaultPaneConfigs[panetype][subtype]();
	if(!conf) conf = {};
	conf.nodeinfo = emptyNode();
	return conf;
}

var _typeConfigs = {};

let rootConfig = 
 {
		typesAllowedForChildNodes : new Set(),
		actionViewConf: { paneType: "default", config: getDefaultConfig('view') },
		actionAddConf: { paneType: "default", config: getDefaultConfig('add') },
		actionEditConf: { paneType: "default", config: getDefaultConfig('edit') },
		iconClassName: 'ico-folder'
}


_typeConfigs[TYPE_ROOT] = rootConfig;

function createTypeConfigWithDefaults(
	typename,
	listOfAllowedChildren = [], 
	iconClass = '',
	canAddToTopLevel = true,
	view = 'default', 
	add = 'default', 
	edit = 'default', 
	moveparent = 'default', 
	movechildren = 'default') {

	let newTC = {};
	newTC.typesAllowedForChildNodes = new Set(listOfAllowedChildren);
	newTC.actionViewConf = (view) ? { paneType: view, config: getDefaultConfig('view') } : null;
	newTC.actionAddConf = (add) ? { paneType: add, config: getDefaultConfig('add') } : null;
	newTC.actionEditConf = (edit) ? { paneType: edit, config: getDefaultConfig('edit') } : null;
	newTC.actionMoveParentConf = (moveparent) ? { paneType: "default", config: {} } : null;
	newTC.actionMoveChildrenConf = (movechildren) ? { paneType: "default", config: {} } : null;
	newTC.iconClassName = iconClass || 'ico-miscfile';
	newTC.getValueForSorting = ((node) => {	return node[PROP_LABEL]; })

	if(canAddToTopLevel) 
		rootConfig.typesAllowedForChildNodes.add(typename);
	_typeConfigs[typename] = newTC;
	return newTC;

}

/*
	return {
		typesAllowedForChildNodes : new Set(listOfAllowedChildren),
		actionViewConf: { paneType: "default", config: getDefaultConfig('view') },
		actionAddConf: { paneType: "default", config: getDefaultConfig('add') },
		actionEditConf: { paneType: "default", config: getDefaultConfig('edit') },
		actionMoveParentConf: { paneType: "default", config: {} },
		actionMoveChildrenConf: { paneType: "default", config: {} },
	}
*/


createTypeConfigWithDefaults('unknown',[],'',false);



// when adding a type to the app, have to configure it here, plus add it to ctxmenu and 


/*
TYPE_CLIENT

_typeConfigs["foobar"] = {
		typesAllowedForChildNodes : new Set(["typeA","typeB"]),
		actionViewConf: { paneType: "default", config: {...} },
		...
		getValueForSorting: function(node) {...}
	}
_typeConfigs[TYPE_ROOT].typesAllowedForChildNodes.add("foobar");

*/
const TYPE_CLIENT = "Client";
const TYPE_PROJECT = "Project";
const TYPE_FOLDER = "Folder";
const TYPE_HOST = "Host";
const TYPE_PORT = "Port";
const TYPE_TEXT = "Text";
const TYPE_IMAGE = "Image";
const TYPE_FILE = "File";
const TYPE_NOTE = "Note";
const TYPE_TABLE = "Table";
const TYPE_ANNOTATION = "Annotation";
const TYPE_TAG = "Tag";
const TYPE_REPORT = "Report";
const TYPE_SECTION = "Section";
const TYPE_JOBREQ = "Job Request";

createTypeConfigWithDefaults(TYPE_CLIENT, [TYPE_FOLDER, TYPE_PROJECT, TYPE_NOTE, TYPE_TABLE, TYPE_ANNOTATION, TYPE_FILE],'ico-user');
createTypeConfigWithDefaults(TYPE_PROJECT, [TYPE_FOLDER, TYPE_REPORT, TYPE_NOTE, TYPE_TABLE, TYPE_TEXT, TYPE_IMAGE, TYPE_ANNOTATION, TYPE_FILE],'ico-book',false);
createTypeConfigWithDefaults(TYPE_FOLDER, [TYPE_FOLDER, TYPE_CLIENT, TYPE_PROJECT, TYPE_NOTE, TYPE_TABLE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE, TYPE_IMAGE, TYPE_TAG, TYPE_HOST, TYPE_PORT, TYPE_REPORT, TYPE_SECTION],'ico-folder');

let c_host = createTypeConfigWithDefaults(TYPE_HOST, [TYPE_FOLDER, TYPE_PORT, TYPE_IMAGE, TYPE_TEXT, TYPE_NOTE, TYPE_TABLE, TYPE_ANNOTATION, TYPE_FILE],'ico-host',false);
c_host.getValueForSorting = (node) => {	return convertIPtoNum(node[PROP_LABEL]); }

let c_port = createTypeConfigWithDefaults(TYPE_PORT, [TYPE_FOLDER, TYPE_PROJECT, TYPE_NOTE, TYPE_TABLE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE],'ico-hash',false);
c_port.getValueForSorting = (node) => {	return parseInt(node[PROP_LABEL].replace('/tcp','').replace('/udp',''),10); }

createTypeConfigWithDefaults(TYPE_TEXT, [TYPE_ANNOTATION],'ico-code',false,'textbody',null,null);
createTypeConfigWithDefaults(TYPE_IMAGE, [TYPE_ANNOTATION],'ico-img',false,'download','fileupload',null);
createTypeConfigWithDefaults(TYPE_FILE, [TYPE_ANNOTATION],'ico-miscfile',false,'download','fileupload',null);
createTypeConfigWithDefaults(TYPE_NOTE, [TYPE_ANNOTATION],'ico-note',false,'editor','editor','editor');
createTypeConfigWithDefaults(TYPE_TABLE, [TYPE_ANNOTATION],'ico-table',false,'table','table','table');
createTypeConfigWithDefaults(TYPE_ANNOTATION, [],'ico-info',false,null,null,'default');
createTypeConfigWithDefaults(TYPE_TAG, [TYPE_FOLDER, TYPE_CLIENT, TYPE_PROJECT, TYPE_NOTE, TYPE_TABLE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE, TYPE_IMAGE, TYPE_TAG, TYPE_HOST, TYPE_PORT, TYPE_REPORT],'ico-tag',false);
createTypeConfigWithDefaults(TYPE_REPORT, [TYPE_SECTION, TYPE_JOBREQ],'ico-report',false);
createTypeConfigWithDefaults(TYPE_SECTION, [TYPE_SECTION, TYPE_NOTE, TYPE_TABLE, TYPE_ANNOTATION, TYPE_FILE, TYPE_TEXT, TYPE_IMAGE],'ico-mark',false);
//createTypeConfigWithDefaults(TYPE_FINDING, [TYPE_FOLDER, TYPE_NOTE, TYPE_TABLE, TYPE_ANNOTATION, TYPE_FILE, TYPE_TEXT, TYPE_IMAGE],false);
createTypeConfigWithDefaults(TYPE_JOBREQ, [],'ico-send',false,'default','default','default');


//write a loop that iterates thru all typeConfigs and checks whether its members contain config.nodeinfo
//if not, create an empty node.... or maybe just force set it???

function setNodeInfo(typeConfObj, actionConf)
{
	if(typeConfObj[actionConf] && typeConfObj[actionConf].config && !typeConfObj[actionConf].config.nodeinfo) 
		typeConfObj[actionConf].config.nodeinfo = emptyNode();
}

for (const [key, value] of Object.entries(_typeConfigs)) {
	console.log(`${key}: ${value}`);
	setNodeInfo(value, 'actionViewConf');
	setNodeInfo(value, 'actionEditConf');
	setNodeInfo(value, 'actionAddConf');
	setNodeInfo(value, 'actionMoveParentConf');
	setNodeInfo(value, 'actionMoveChildrenConf');
}

///****************** Move Vue bindings here, and the panesIndex will bind to their data.v objects 
// eg. v_editAndView_editor.$data.v
// eg. v_editAndView_editor.$root.testEventHandler
// and not... 
// the vue objects will bind to paneConfig

var _panesIndex = {
	//main_pane divs:
	view: {
		//pane key 
		"default" : {
			divID: "view_default", //DOMelementID
			v: { config: getDefaultConfig('view')},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		//todo: file, image, text, note, annotation(nothing), folder(?)
		"download" : {
			divID: "view_download", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		"textbody" : {
			divID: "view_textbody", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: async function(){
				let nodeInfo = this.v.config.nodeinfo;
				await updateAttachmentNodeIfChangedOrEmpty(nodeInfo);
				//without the forceUpdate, the TextData is not showing upon the first viewing attempt, but will show on the second
				v_view_textbody.$forceUpdate(); 
			}, 
		},
		"editor" : {
			divID: "view_editor", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: async function(){
				//need to fetch attachment body and populate quill
				let nodeInfo = this.v.config.nodeinfo;
				await updateAttachmentNodeIfChangedOrEmpty(nodeInfo);
				populateQuill(nodeInfo);
				setQuillVisualState("disable");
				quillGlobal.CurrentUid = nodeInfo[PROP_UID];
			}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		"table" : {
			divID: "view_table", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: async function(){
				let nodeInfo = this.v.config.nodeinfo;
				await updateAttachmentNodeIfChangedOrEmpty(nodeInfo);
				populateJexcel(nodeInfo);
				setJexcelVisualState("disable");
				jexcelGlobal.CurrentUid = nodeInfo[PROP_UID];
			}, //get config using this.v.config  (will have nodeinfo and parentID)
		},

	},
	othermain: {
		//pane key 
		"search" : {
			divID: "othermain_search", //DOMelementID
			v: { config: _defaultPaneConfigs['othermain']['search']()},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
	},
	// for edit panetypes:
	// onBeforeCopyNode() paneConfig.nodeinfo contains the original node, to allow actions on it to occur
	// onBeforeShow()  paneConfig.nodeinfo contains a copy of the node, run before pane is shown
	// onAfterSubmit() paneConfig.nodeinfo contains a copy of the node, run after submitAction button is clicked (put upsert request in here)
	edit: {
		"default" : {
			divID: "edit_default",
			v: { config:  getDefaultConfig('edit')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){ await upsertGeneric(this.v.config.nodeinfo); },
		},
		"editor" : {
			divID: "view_editor",
			v: { config:  getDefaultConfig('edit')},
			onBeforeCopyNode: async function(){
				//need to fetch attachment body if its not there or needs an update
				await updateAttachmentNodeIfChangedOrEmpty(this.v.config.nodeinfo);
			}, //get config using this.v.config  (will have nodeinfo and parentID)
			onBeforeShow: function(){
				populateQuill(this.v.config.nodeinfo);
				setQuillVisualState("enable");
			},
			onAfterSubmit: async function(){
				let nodeInf = this.v.config.nodeinfo;
				getQuillEdits(nodeInf);
				let x_changed = (nodeInf[PROP_TEXTDATA] != _index[nodeInf[PROP_UID]][PROP_TEXTDATA]);
				let l_changed = (nodeInf[PROP_LABEL] != _index[nodeInf[PROP_UID]][PROP_LABEL]);
				if(!x_changed)
					nodeInf[PROP_TEXTDATA] = null;
				if(x_changed || l_changed)
					await upsertGeneric(nodeInf);
				setQuillVisualState("disable");
				quillGlobal.CurrentUid = nodeInf[PROP_UID];
			},
		},
		"table" : {
			divID: "view_table",
			v: { config:  getDefaultConfig('edit')},
			onBeforeCopyNode: async function(){
				//need to fetch attachment body if its not there or needs an update
				await updateAttachmentNodeIfChangedOrEmpty(this.v.config.nodeinfo);
			}, //get config using this.v.config  (will have nodeinfo and parentID)
			onBeforeShow: function(){
				populateJexcel(this.v.config.nodeinfo);
				setJexcelVisualState("enable");
			},
			onAfterSubmit: async function(){
				let nodeInf = this.v.config.nodeinfo;
				getJexcelEdits(nodeInf);
				let x_changed = (nodeInf[PROP_TEXTDATA] != _index[nodeInf[PROP_UID]][PROP_TEXTDATA]);
				let l_changed = (nodeInf[PROP_LABEL] != _index[nodeInf[PROP_UID]][PROP_LABEL]);
				if(!x_changed)
					nodeInf[PROP_TEXTDATA] = null;
				if(x_changed || l_changed)
					await upsertGeneric(nodeInf);
				setJexcelVisualState("disable");
				jexcelGlobal.CurrentUid = nodeInf[PROP_UID];
			},		
		},
	},
	//modal divs:
	add: {
		"default" : {
			divID: "add_default",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){ await upsertGeneric(this.v.config.nodeinfo); },
			},
		//todo: file, image, text, note, annotation, folder
		"fileupload" : {
			divID: "add_fileupload",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){clearFileUploadFormInput();},
			onAfterSubmit: async function(){ await fileupload(this.v.config.nodeinfo);},
			},
		"editor" : { //we show a dialog to enter the note name, create the empty note and show the actual editor
			divID: "add_editor",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){
				let ninfo = this.v.config.nodeinfo;
				await upsertGeneric(ninfo); 
				v_action_funcs['edit'](ninfo[PROP_UID]);
				},
			},
		"table" : { //we show a dialog to enter the note name, create the empty note and show the actual editor
			divID: "add_table",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){
				let ninfo = this.v.config.nodeinfo;
				await upsertGeneric(ninfo); 
				v_action_funcs['edit'](ninfo[PROP_UID]);
				},
			},
	},
	moveparent:  {
		"default" : {},
	},
	movechildren: {
		"default" : {},
	}
};

const HISTORY_VIEWNODE = 'node';
const HISTORY_SEARCH = 'search';

var MainPaneHistory = [];
// [ {'type':'viewNode','data':'0x123'}, {'type':'viewSearch', 'data': 's1'}... ]
var HistoryPosition = -1;

function historyPush(type, data) {
	if (HistoryPosition > -1)
		MainPaneHistory = MainPaneHistory.slice(0,HistoryPosition+1);
	MainPaneHistory.push({'type':type, 'data': data});
	HistoryPosition++;
	setNavIcons();
}

//historyPush('start',null);

function setNavIcons() {
	vue_topnav.$data.iconBack = (HistoryPosition > 0) ? 'ico-left-arr' : 'ico-left-arr-dis'
	vue_topnav.$data.iconFwd = (HistoryPosition < MainPaneHistory.length - 1) ? 'ico-right-arr' : 'ico-right-arr-dis'
}

function historyBack() {
	if (HistoryPosition > 0) {
		HistoryPosition--;
	}
	setNavIcons();
	return MainPaneHistory[HistoryPosition];
}

function historyForward() {
	if(HistoryPosition < MainPaneHistory.length - 1) {
		HistoryPosition++;
	}
	setNavIcons();
	return MainPaneHistory[HistoryPosition];
}

function navigateMainPaneBack() {
console.log('navigateMainPaneBack');
	let prevView = historyBack();
	if (!prevView)
		return;
	let prevAction = prevView['type'] == HISTORY_VIEWNODE ? 'view' : 'search';
	v_action_funcs[prevAction](prevView['data']);
}

function navigateMainPaneForward() {
console.log('navigateMainPaneForward');
	let nextView = historyForward();
	if (!nextView)
		return;
	let nextAction = nextView['type'] == HISTORY_VIEWNODE ? 'view' : 'search';
	v_action_funcs[nextAction](nextView['data']);
}

function hasNextHistory() {
	return (HistoryPosition < MainPaneHistory.length - 2)
}

function hasPrevHistory() {
	return (HistoryPosition > 0)
}


SearchCache = {};

async function getSearch(_query, searchRootNode, cached = true) {
	let searchRootUid = searchRootNode[PROP_UID];
	let queryKey = `(${searchRootUid}) ${_query}`
	if(cached && SearchCache[queryKey])
		return SearchCache[queryKey];
	let serverResponse = await fetchNodes([searchRootUid], PROP_LABEL , 'allofterms', _query, 20);
	let queryObj = { nodes: serverResponse['nodes'] || [], nodelabel: searchRootNode[PROP_LABEL], query: _query };
	SearchCache[queryKey] = queryObj;
	return queryObj;
	//let test = emptyNode('0x0',TYPE_ANNOTATION)
	//test[PROP_LABEL] = 'Test Result';
	//test[PROP_DETAIL] = query;
	//return [test];
}

// show/hide the main panes -------------------------------------------------

const D_HIDE = "none";
const D_SHOW = "block";

function getPaneDivs(panesOfType, outDict)
{
	for (const [key, value] of Object.entries(panesOfType)) {
		//console.log(`${key}: ${value}`);
		let div = document.getElementById(value.divID);
		if(div)
			outDict[value.divID] = div;
	}
}

var mainPaneDivLookup = {};
var modalPaneDivLookup = {};

getPaneDivs(_panesIndex.view,mainPaneDivLookup);
getPaneDivs(_panesIndex.edit,mainPaneDivLookup);
getPaneDivs(_panesIndex.othermain,mainPaneDivLookup);
getPaneDivs(_panesIndex.add,modalPaneDivLookup);
getPaneDivs(_panesIndex.moveparent,modalPaneDivLookup);
getPaneDivs(_panesIndex.movechildren,modalPaneDivLookup);


function switchPane(paneType, paneName)
{
	let _divID = _panesIndex[paneType][paneName].divID;
	
	//main_pane divs
	if(paneType == 'view' || paneType == 'edit' || paneType == 'othermain')
	{
		for (const [key, value] of Object.entries(mainPaneDivLookup))
			value.style.display = (key == _divID) ? D_SHOW : D_HIDE;
	}
	else
	//modal divs
	{
		for (const [key, value] of Object.entries(modalPaneDivLookup))
			value.style.display = (key == _divID) ? D_SHOW : D_HIDE;
		// show the modal div
		toggleModal();
	}
}

// event handlers ------------------------------------------------------------

function HideContextMenu(){
	document.getElementById("ctxmenu-div").style.display = "none";
}

function showLoading(waiting)
{
	let elem = document.getElementById("body_container");
	elem.style.cursor = (waiting) ? "wait" : "auto";
//	let logo = document.getElementById("id_logo");
//	let load = document.getElementById("id_load");
	let logo = document.getElementById("ico-logo");
	let load = document.getElementById("ico-load");
	//let useElement = logo.getElementsByTagName("use")[0];
	if(waiting)
	{
		logo.style.display = "none";
		load.style.display = "inline-block";
	}
	//	logo.classList.replace('ico-logo', 'ico-load');
	//	useElement.href.baseVal = "#ico-load"
	else
	{
		load.style.display = "none";
		logo.style.display = "inline-block";
	}
	//	logo.classList.replace('ico-load', 'ico-logo');
	//	useElement.href.baseVal = "#ico-logo"
}


function toggleModal()
{
   document.getElementById("modal_div").classList.toggle('is-active');
}

function clearFileUploadFormInput()
{
	const fileName = document.getElementById('at_file_name');
      fileName.textContent = 'No File Selected';
}

function serialise(jsonObj) {
    return JSON.stringify(jsonObj, (key,value) =>
	{
		if (key==PROP_PARENTREFS 
			|| key==PROP_CHILDREFS 
			|| key==PROP_LASTMOD 
			|| key == PROP_VUEREF
			|| key == 'isOpen' 
			|| key == 'hasChanged' 
			|| key == 'isViewed' 
			|| key == 'dgraph.type') 
			return undefined;
		//nullify certain values instead of sending empty string, eg. t, x, e, c
		if (value == '' && (
			key==PROP_TEXTDATA 
			|| key==PROP_BINARYDATA 
			|| key==PROP_TIME 
			|| key==PROP_EDITING 
			|| key==PROP_TYPE)) 
			return undefined;
		else return value;
	} );
}

function clearList(list)
{
	if(list)
		while(list.length > 0)
			list.pop()
}

function extendList(list, listToAdd)
{
	if(list && listToAdd)
		listToAdd.forEach(listItem => list.push(listItem));
}


function sortList(list)
{
	//need to do the sorting here because Vue is hanging when using computed or method sorting (maybe an issue with the circular references in/out?)
	list.sort(
		(nodeA,nodeB) => {
			let aType = nodeA[PROP_TYPE];
			let bType = nodeB[PROP_TYPE];
			let aVal = (_typeConfigs[aType] && _typeConfigs[aType].getValueForSorting) ? _typeConfigs[aType].getValueForSorting(nodeA) : nodeA[PROP_LABEL]; 
			let bVal = (_typeConfigs[bType] && _typeConfigs[bType].getValueForSorting) ? _typeConfigs[bType].getValueForSorting(nodeB) : nodeB[PROP_LABEL]; 
			let aIsString = (typeof aVal) === 'string';
			let bIsString = (typeof bVal) === 'string';
			if( aIsString || bIsString ) 
				return (aIsString && bIsString) ? aVal.localeCompare(bVal) : ((aIsString) ? -1 : 1);

			aVal = (isNaN(aVal)) ? Infinity : aVal;
			bVal = (isNaN(bVal)) ? Infinity : bVal;
			return (aVal < bVal) ? -1 : ((aVal > bVal) ? 1 : 0 );
			//^alpha is lower than numeric
		}	
	);
	
}


function clearObjectProperties(obj)
{
	for (var prop in obj) {
		if (obj.hasOwnProperty(prop)) {
			delete obj[prop];
		}
	}
}

const ip_rgx = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/

function convertIPtoNum(ipstr) {
  let octs = ipstr.split('.');
  return (octs[0] * 16777216.0) + (octs[1] * 65536.0) + (octs[2] * 256.0) + octs[3] * 1.0;
}


//this should be modified to return a result to indicate whether error or success
// the result can be interpreted by the 'add' dialog so an error can be shown or the dialog closed if successful
async function upsertGeneric(node)
{	
	showLoading(true);
	console.log("upsert: ",serialise(node));
	await fetch('upsert',{
		method: 'POST',
		headers: {
		  'Content-Type': 'application/json'
		},
		body: '['+serialise(node)+']' // body data type must match "Content-Type" header
	})
	.then(response => response.json())
	.then(rdata => { 
		console.log(JSON.stringify(rdata));
		if(rdata && rdata.length > 0)
		{
			if(!_index[rdata[0]])
				_index[rdata[0]] = emptyNode(rdata[0]);
		}
		else
		{
			console.log("an error occurred when attempting to upsert node");//deal with the error
		}
	});
	showLoading(false);

	await refreshNodes();
}


//fileupload
async function fileupload(node)
{
	const input = document.getElementById('at_file');

	let params = {};
	if(node[PROP_UID])
		params.attachid = node[PROP_UID];
	params.parentid = node[PROP_PARENTLIST][0].uid;
	
	let data = new FormData();
	data.append('filedata', input.files[0]);
	data.append('type', 'file_upload');
	data.append('_p', JSON.stringify(params));

	await fetch('upload', {
	  method: 'POST',
	  //mode: 'no-cors', //for testing with httpbin
	  //!!important: don't set the content-type
	  body: data
	  }).then(response => response.text()).then( response => {
			console.log(response);
			if(response.startsWith('0x'))
			{
				_index[response] = emptyNode(response);
			}
		});//.then(rdata => { console.log(JSON.stringify(rdata)); }
	//);
	
	await refreshNodes();
}



async function moveNodeToNewParent(node, newParentNode)
{	
	let existingParentUids = []
	node[PROP_PARENTREFS].forEach(n => existingParentUids.push(n[PROP_UID]));
	
	let moveData = {
		nodes: [node[PROP_UID]],
		parents: existingParentUids,
		children: [],
		newparent: newParentNode[PROP_UID]
	}
	showLoading(true);
	console.log("move to new parent: ",serialise(node));
	await fetch('move',{
		method: 'POST',
		headers: {
		  'Content-Type': 'application/json'
		},
		body: JSON.stringify(moveData) // body data type must match "Content-Type" header
	})
	.then(response => response.json() )
	.then(rdata => { 
		console.log(JSON.stringify(rdata));
		if(rdata && rdata.error)
		{
			console.log("move nodes failed: ",rdata.message);//need to deal with any errors
		}
	});
	showLoading(false);

	await refreshNodes();
}


async function copyNodeToParent(node, newParentNode)
{	
	let newCopy = emptyNode();
	updateNode(newCopy, node);
	newCopy[PROP_PARENTLIST] = [{uid: newParentNode[PROP_UID]}];
	newCopy[PROP_CHILDLIST] = [];
	newCopy[PROP_UID] = '';
	//todo: remember to nuke lnk[] too when implemented
	console.log(serialise(newCopy));
	await upsertGeneric(newCopy);
}



//updatenodes (send list of uids to server and get nodes (newer than last update)

var _lastUpdateTime_Server = 0;
var _lastUpdateTime_Browser = Date.now();

function setLastUpdatedTime(serverTimestamp) {
	_lastUpdateTime_Server = serverTimestamp;
	_lastUpdateTime_Browser = Date.now();
}

function getUidsFromIndex()
{
	let listOfUids = [];
	for (const [key, value] of Object.entries(_index)) {
		listOfUids.push(key);
	}
	return listOfUids;
}

function refsAndListContainSameUids(refs, list)
{
	if (refs.length != list.length)
		return false;
	let refsSet = new Set(refs);
	for (let i=0; i < list.length; i++)
		if(!refsSet.has(list[i][PROP_UID]))
			return false;
	return true;
}

async function fetchChildNodes(nodeid)
{
	let node = _index[nodeid];
	if( node 
		&& (node[PROP_CHILDLIST].length) 
		&& !refsAndListContainSameUids(node[PROP_CHILDLIST], node[PROP_CHILDREFS]))
		await fetchNodes([nodeid],PROP_LASTMOD,'gt',0,1);
}


async function refreshNodes()
{
	await fetchNodes(getUidsFromIndex());
}

async function fetchInitialNodes()
{
	setLastUpdatedTime(0);
	//this will fetch only the root node:
	await fetchNodes(null,PROP_LASTMOD,'gt',0,0);
	//there should be only two nodes in the index after this initial request:
	// _index['.'] (the placeholder for root node)
	// _index['0xN'] (the actual root node
	for (const [key, value] of Object.entries(_index)) {
		if(key != '.') {
			//G.root = value;
			updateNode(G.root,value);
			createEdgesForNode(G.root);
			delete _index['.'];
			_index[G.root[PROP_UID]] = G.root;
		}
	}
	await fetchChildNodes(G.root.uid,0);
}

async function fetchNodes(_uids, _field = PROP_LASTMOD, _op = 'gt', _val = _lastUpdateTime_Server, _depth = 0)
{
//  /nodes POST
//  { field=m op='gt' val=_lastUpdateTime_Server depth=0
//   uids = [] }
	let data = { field: _field, op: _op, val: `${_val}`, depth: _depth, uids: _uids };
	let serverResp = {};
	showLoading(true);
console.log('A'+JSON.stringify(data));
	await fetch('/nodes', {
		method: 'POST',
		//mode: 'no-cors', //for testing with httpbin
		headers: {
		  'Content-Type': 'application/json'
		},
		body: JSON.stringify(data)
	}).then(response => response.json() )
	.then(rdata => { 
		console.log(JSON.stringify(rdata));
		serverResp = rdata;
		if(rdata && rdata.nodes && !rdata.error)
		{
			updateNodeTree(rdata);
		}
		else
		{
			console.log("update nodes failed: ",rdata.message);//deal with the error
		}
	});//.catch(console.log("update nodes failed: caught exception."));
	showLoading(false);	
	return serverResp;
}

function createEdgesFromUids(listUidObjs)
{
	let tmpList = [];
	if(listUidObjs)
		listUidObjs.forEach(uidobj => {
			if(_index[uidobj.uid]) 
				tmpList.push(_index[uidobj.uid]);
		});
	return tmpList;
}

function createEdgesFromUidsInplace(listUidObjs,existingList)
{
	if(listUidObjs)
		listUidObjs.forEach(uidobj => {
			if(_index[uidobj.uid]) 
				existingList.push(_index[uidobj.uid]);
		});
}


function createEdgesForNode(node)
{
		//root node doesn't have parentrefs, what to do?
		clearList(node[PROP_PARENTREFS]);
		createEdgesFromUidsInplace(node[PROP_PARENTLIST],node[PROP_PARENTREFS]);

		clearList(node[PROP_CHILDREFS]);
		createEdgesFromUidsInplace(node[PROP_CHILDLIST],node[PROP_CHILDREFS]);

		///*************
		// the sorting of child references (alpha numeric) was done around this stage because using VueJS computed/methods was hanging,
		// so sort them during edge creation.
		///*************
		sortList(node[PROP_CHILDREFS]);
		if(node[PROP_PARENTREFS] && node[PROP_PARENTREFS].length) {
			node[PROP_PARENTREFS].forEach( parent => sortList(parent[PROP_CHILDREFS]) );
		}
}

function updateNode(existingNode, updatedNode)
{
	// safe assumptions: queryNodes always returns uid, label, detail, customdata, time, editing, lastmod, in, out *if* they are present
	//  so, if any of these are not present, then they are null. 
	//  we don't want to create fields if they don't already exist *except* for in, out
	//  if in or out don't exist then create empty arrays

	let oldHasChangedValue = existingNode.hasChanged;
	
	existingNode.hasChanged = (updatedNode[PROP_LASTMOD] != existingNode[PROP_LASTMOD]); 
	
	if(existingNode.isViewed && existingNode.hasChanged)
		existingNode.isViewed = false;
	
	
	for (const [key, value] of Object.entries(updatedNode)) {

	  existingNode[key] = value;
	  //console.log("update:",key,value);
	}
}

function updateNodeTree(serverResponse)
{

	let nodes = serverResponse.nodes;
	for (let i = 0; i < nodes.length; i++)
	{
		//  if exists in mainindex then update
		let incomingNode = nodes[i];

		incomingNode[PROP_PARENTLIST] = incomingNode[PROP_PARENTLIST] || [];
		incomingNode[PROP_PARENTREFS] = incomingNode[PROP_PARENTREFS] || [];
		incomingNode[PROP_CHILDLIST] = incomingNode[PROP_CHILDLIST] || [];
		incomingNode[PROP_CHILDREFS] = incomingNode[PROP_CHILDREFS] || [];
		incomingNode[PROP_RELATIONS] = incomingNode[PROP_RELATIONS] || [];

		let tnode = _index[incomingNode.uid];

		if(tnode)
			updateNode(tnode, incomingNode);
		else
		{
			incomingNode.hasChanged = true;
			incomingNode.isViewed = false;
			incomingNode.isOpen = false;
			_index[incomingNode.uid] = incomingNode;
		}
	}

	for (let i = 0; i < nodes.length; i++)	
		createEdgesForNode(_index[nodes[i].uid]);

	setLastUpdatedTime(serverResponse.timestamp);
	//vue_col_groups.$forceUpdate();
}

async function updateAttachmentNodeIfChangedOrEmpty(node,datafield = PROP_TEXTDATA)
{
	if(node.hasChanged || !node[datafield])
	{
console.log("att refresh: ",node.m);
		showLoading(true);
		await fetch('/attachment/'+node[PROP_UID]+'/0')
		.then(response => response.json())
			.then(data => { 
				updateNodeTree(data);
				}
			);
		showLoading(false);
	}
	else {console.log("att hasnt changed or already has datafield: ",node.hasChanged,node[datafield]);}
}


/////////////////////////////////////////////////////////////////////////////////////////
//     VueJS Bindings
/////////////////////////////////////////////////////////////////////////////////////////

function startDragging(evt, id, action) {
console.log('startDragging',id,action);
	evt.dataTransfer.dropEffect = action;
	evt.dataTransfer.effectAllowed = action;
	evt.dataTransfer.setData('action', action);
	evt.dataTransfer.setData('itemID', id);
}

// define the tree-item component
Vue.component("tree-item", {
	template: "#item-template",
	props: {
	  item: Object ,   //these properties can be accessed/modified externally, as well as in computed/methods (refer to it using this.item)
	  depth: Number
	},
	data: function() {  //component instance's initial state is obtained from here, refer to data in methods/computed using this.isOpen
	  return {
		isOpen: false,
	  };
	},
	mounted: function() {
		this.item[PROP_VUEREF] = this;
	},
	computed: {

	  //can have some additional logic when displaying name (eg. truncating, combining label + detail)
	  getIndent: function() {
		console.log('spacing ',this.depth);
		return (this.depth * 10) + 'px';
	  },
	},
	methods: {
		getIcon: function() {
			if(!_typeConfigs[this.item[PROP_TYPE]])
				return 'ico-miscfile';
			return _typeConfigs[this.item[PROP_TYPE]].iconClassName || 'ico-miscfile';
		},
		showCtxMenu: function (event,nodeID) {
			console.log(event,nodeID);
			  contextMenuFor("ctxmenu-div",event,nodeID);
		},
		viewNode: function(e, id) {
			console.log(e,id);
			historyPush(HISTORY_VIEWNODE,id);
			v_action_funcs['view'](id);
		},
		toggle: function(id) {
			if (this.hasChildren) {
			  if(!this.isOpen) 
				fetchChildNodes(id);
			  this.isOpen = !this.isOpen;
			}
		},
	    hasChildren: function() {
			return this.item[PROP_CHILDLIST] && this.item[PROP_CHILDLIST].length;
		},
		isCurrentlySelected: function() {
			return this.item[PROP_UID] == v_currently_selected_node.node[PROP_UID];
		},
		name: function() {
			console.log("name this.item",this.item);
			return this.item[PROP_LABEL];
		},
		startDrag: function(evt, id) {
			startDragging(evt, id, 'move');
		},
		onDrop: async function (evt) {
			const srcNodeID = evt.dataTransfer.getData('itemID');
			const action = evt.dataTransfer.getData('action');
			console.log('onDrop: ',action,srcNodeID,this.item[PROP_UID]);
			if(action == 'copy')
				await v_action_funcs['copy'](srcNodeID,this.item[PROP_UID]);
			else
				await v_action_funcs['move'](srcNodeID,this.item[PROP_UID]);
		},
		makeFolder: function() {
		},
	}
});



var v_tree_pane = new Vue({
	el: "#v_tree_pane",
	data: {
	  treeData: G
	},
	methods: {
		makeFolder: function(item) {
			Vue.set(item, "children", []);
			this.addItem(item);
		},
		addItem: function(item) {
			item.children.push({
			  name: "new stuff",
			  children: [] //**added this and now mchild will work for all chidren
		});
	  }
	}
});

function contextMenuFor(ctxmenudiv,event,nodeID)
{
	event.preventDefault();

	let n = _index[nodeID];

	if(n) {
		G.ctxmenuData = emptyCtxMenuData(n[PROP_UID]);

		let nConfig = _typeConfigs[n[PROP_TYPE]] || _typeConfigs['unknown'];

		if(nConfig.actionEditConf)
			G.ctxmenuData.mainOptions.push("edit");

		let allowedToAdd = Array.from(nConfig.typesAllowedForChildNodes || []);
		allowedToAdd.forEach((typename,index) => {G.ctxmenuData.addOptions.push(`+${typename}`)});

		let menu = document.getElementById(ctxmenudiv);
		menu.style.left = event.pageX + 'px';
		menu.style.top = event.pageY + 'px';
		menu.style.display = 'block';

	}
	//nodeID not found, no context menu to show
	return;
}


// {uid:'0x345',mainOptions:['edit','move'],addOptions:['+foo','+bar']}
function emptyCtxMenuData(_uid = '.') {
	return {uid: _uid, mainOptions: [], addOptions: []};
}


var v_action_funcs = { 
	view: async function (uid) { 
		let n = _index[uid];
		let tc = _typeConfigs[(n[PROP_TYPE] || "unknown")] || _typeConfigs.unknown;
		if(tc) {
			let conf =  tc.actionViewConf || _typeConfigs.unknown.actionViewConf;
			_panesIndex.view[conf.paneType].v.config = conf.config;
			_panesIndex.view[conf.paneType].v.config.nodeinfo = _index[uid];
			await _panesIndex.view[conf.paneType].onBeforeShow();
			switchPane('view',conf.paneType);
			n.isViewed = true;
			v_currently_selected_node.node = n;
			if(n[PROP_PARENTREFS]) {
				n[PROP_PARENTREFS][0][PROP_VUEREF].isOpen = true;
			}
		}
	},
	add: async function (typenameOfNew, _uid) { 
		let tc = _typeConfigs[typenameOfNew];
		if(tc) {
			let conf =  tc.actionAddConf || _typeConfigs.unknown.actionAddConf;
			_panesIndex.add[conf.paneType].v.config = conf.config;
			let newN = emptyNode('',typenameOfNew);
			newN[PROP_PARENTLIST].push({uid: _uid});
			_panesIndex.add[conf.paneType].v.config.nodeinfo = newN;
			await _panesIndex.add[conf.paneType].onBeforeShow();
			switchPane('add',conf.paneType);
		}
	},
	edit: async function (uid) { 
		let n = _index[uid];
		let tc = _typeConfigs[(n[PROP_TYPE] || "unknown")] || _typeConfigs.unknown;
		if(tc) {
			let conf =  tc.actionEditConf || _typeConfigs.unknown.actionEditConf;
			_panesIndex.edit[conf.paneType].v.config = conf.config;
			
			if(_panesIndex.edit[conf.paneType].onBeforeCopyNode) {
				_panesIndex.edit[conf.paneType].v.config.nodeinfo = n;
				await _panesIndex.edit[conf.paneType].onBeforeCopyNode();
			}			
			let tmpNodeCopy = emptyNode(n[PROP_UID]);
			tmpNodeCopy[PROP_LABEL] = n[PROP_LABEL] || null;
			tmpNodeCopy[PROP_DETAIL] = n[PROP_DETAIL] || null;
			tmpNodeCopy[PROP_CUSTOM] = n[PROP_CUSTOM] || null;
			tmpNodeCopy[PROP_TEXTDATA] = n[PROP_TEXTDATA] || null;
			tmpNodeCopy[PROP_TIME] = n[PROP_TIME] || null;
			tmpNodeCopy.hasChanged = n.hasChanged;
			_panesIndex.edit[conf.paneType].v.config.nodeinfo = tmpNodeCopy;
			
			await _panesIndex.edit[conf.paneType].onBeforeShow();
			switchPane('edit',conf.paneType);
			n.isViewed = true;
			historyPush(HISTORY_VIEWNODE,n[PROP_UID]);
			v_currently_selected_node.node = n;
		}
	},
	search: async function(queryData, cached = true) { 
		queryresults = await getSearch(queryData.query, queryData.node, cached);
		_panesIndex.othermain.search.v.config.results = queryresults;
		switchPane('othermain','search');
	},
	copy: async function (srcUID, targetUID) { 

		//reject obvious stuff: src and target are same, and can't move the root node
		if(srcUID == targetUID)
		{
			notification('Can\'t copy to same item');
			return;
		}

		if(srcUID == G.root[PROP_UID])
		{
			notification('Can\'t copy the root element');
			return;
		}

		let nSrc = _index[srcUID];
		let nTarget = _index[targetUID];

		
		//check whether target type allows children of src type and reject if not so
		let targetTC = _typeConfigs[nTarget[PROP_TYPE]];
		if(!targetTC.typesAllowedForChildNodes.has(nSrc[PROP_TYPE]))
		{
			notification(`${nSrc.ty}s are not allowed to be added to ${nTarget.ty}s`);
			return;
		}
		
		console.log(`copy Src: ${nSrc.uid} (${nSrc.l}), Target: ${nTarget.uid} (${nTarget.l})`);

		//do the copy:
		await copyNodeToParent(nSrc, nTarget);
	},	
	move: async function (srcUID, targetUID) { 

		//reject obvious stuff: src and target are same, and can't move the root node
		if(srcUID == targetUID)
		{
			notification('The source and destination are the same');
			return;
		}

		if(srcUID == G.root[PROP_UID])
		{
			notification('Can\'t move the root element');
			return;
		}

		let nSrc = _index[srcUID];
		let nTarget = _index[targetUID];


		//check if target is already the direct parent of src and reject if so
		if(nSrc[PROP_PARENTREFS] && (nSrc[PROP_PARENTREFS].filter(e => e[PROP_UID] == nTarget[PROP_UID]).length > 0))
		{
			console.log(`Target ${nTarget[PROP_LABEL]} is already the parent of ${nSrc[PROP_LABEL]}`);
			return;
		}
		
		//check whether target type allows children of src type and reject if not so
		let targetTC = _typeConfigs[nTarget[PROP_TYPE]];
		if(!targetTC.typesAllowedForChildNodes.has(nSrc[PROP_TYPE]))
		{
			notification(`${nSrc.ty}s are not allowed to be added to ${nTarget.ty}s`);
			return;
		}
		
		//check for creation of a cycle and reject if so
		//**This also needs to be implemented on the server side to prevent DoS
		if(checkIfLinkCreationCausesCycle(nTarget,nSrc))
		{
			console.log(`adding "${nSrc[PROP_LABEL]}" as child of "${nTarget[PROP_LABEL]}" would create a cyclic reference`);
			return;
		}

		console.log(`Move Src: ${nSrc.uid} (${nSrc.l}), Target: ${nTarget.uid} (${nTarget.l})`);
		//do the move:
		await moveNodeToNewParent(nSrc, nTarget);
	},
};

// if adding child to parent, will a cycle be created?
function checkIfLinkCreationCausesCycle(intendedParentNode,tmpTraverseNode) {
	if(!tmpTraverseNode || !tmpTraverseNode[PROP_CHILDREFS])
		return false;
	if(tmpTraverseNode[PROP_UID] == intendedParentNode[PROP_UID])
		return true;
	let result = false;
	tmpTraverseNode[PROP_CHILDREFS].forEach(childN => { result = result || checkIfLinkCreationCausesCycle(intendedParentNode, childN)});
	return result;
}


var v_ctxmenu = new Vue({
	el: "#v_ctxmenu",
	data: {
	  vdata: G
	},
	methods: {
		ctxmenuAction: function (e, ac, uid) {
			console.log ( "ctxmenuAction: ",ac, uid);
			if(ac.startsWith('+')) {
				v_action_funcs['add'](ac.substring(1),uid);
			}
			else
				v_action_funcs[ac](uid);
		}
	}
});


function handleSubmit(ac, pane) {
	console.log ( "handleSubmit: ",ac, pane);
	_panesIndex[ac][pane].onAfterSubmit();
	if(ac != 'view' && ac != 'edit')
		toggleModal();
}


var v_othermain_search = new Vue({
	el: '#v_othermain_search',
	data: { 
	   v: _panesIndex['othermain']['search'].v
	},
	computed: {
	},
	methods : {
        getTypeIcon: function (node) {
			let type = node[PROP_TYPE] || 'unknown';
			let tConf = _typeConfigs[type];
			return (tConf) ? tConf.iconClassName : 'ico-miscfile';
        }, 
		viewNode: function(e, id) {
			//view node
			console.log(e,id);
			historyPush(HISTORY_VIEWNODE,id);
			v_action_funcs['view'](id);
		},
	}
});


var v_view_default = new Vue({
	el: '#v_view_default',
	data: { 
	   v: _panesIndex['view']['default'].v
	},
	computed: {
	},
	methods : {
        getTypeIcon: function (node) {
			let type = node[PROP_TYPE] || 'unknown';
			let tConf = _typeConfigs[type];
			return (tConf) ? tConf.iconClassName : 'ico-miscfile';
        }, 
        loadChildren: function (id) {
			console.log(id);
			fetchChildNodes(id);
        }, 
		viewNode: function(e, id) {
			//view node
			console.log(e,id);
			historyPush(HISTORY_VIEWNODE,id);
			v_action_funcs['view'](id);
		},
		startDrag: function(evt,id) {
			startDragging(evt, id, 'move');
			console.log('start clone: '+id);
		},
		onDrop: async function (evt) {
			const srcNodeID = evt.dataTransfer.getData('itemID');
			const action = evt.dataTransfer.getData('action');
			let item = this.v.config.nodeinfo;
			console.log('onDrop: ',action,srcNodeID,item[PROP_UID]);
			if(action == 'copy')
				await v_action_funcs['copy'](srcNodeID,item[PROP_UID]);
			else
				await v_action_funcs['move'](srcNodeID,item[PROP_UID]);
		},
	}
});

var v_view_download = new Vue({
	el: '#v_view_download',
	data: { 
	   v: _panesIndex['view']['download'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vOpenNewWindow :  function(url){ 
			//console.log(x);
			openNewWindow(url);
		}
	}
});

var v_view_textbody = new Vue({
	el: '#v_view_textbody',
	data: { 
	   v: _panesIndex['view']['textbody'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vCustom :  function(x){ 
			console.log(x);
		}
	}
});

var v_edit_default = new Vue({
	el: '#v_edit_default',
	data: { 
	   v: _panesIndex['edit']['default'].v
	},
	methods : {
        getTypeName: function (id) {
			//console.log(e,id);
			return _index[id][PROP_TYPE];
        }, 
		vSubmit :  function(){ 
			handleSubmit('edit', 'default');
		}
	}
});

var v_add_default = new Vue({
	el: '#v_add_default',
	data: { 
	   v: _panesIndex['add']['default'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'default');
		}
	}
});


var v_add_editor = new Vue({
	el: '#v_add_editor',
	data: { 
	   v: _panesIndex['add']['editor'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'editor');
		}
	}
});

var v_add_table = new Vue({
	el: '#v_add_table',
	data: { 
	   v: _panesIndex['add']['table'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'table');
		}
	}
});


var v_all_editor = new Vue({
	el: '#v_all_editor',
	data: { 
	   v: _panesIndex['edit']['editor'].v,
	   q: quillGlobal
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		startDrag: function(evt) {
			startDragging(evt, this.q.CurrentUid, 'copy');
			console.log('start clone: '+this.q.CurrentUid);
		},
	}
});

var v_all_table = new Vue({
	el: '#v_all_table',
	data: { 
	   v: _panesIndex['edit']['table'].v,
	   j: jexcelGlobal
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		startDrag: function(evt) {
			startDragging(evt, this.j.CurrentUid, 'copy');
			console.log('start clone: '+this.j.CurrentUid);
		},
	}
});


var v_add_fileupload = new Vue({
	el: '#v_add_fileupload',
	data: { 
	   v: _panesIndex['add']['fileupload'].v,
	   filename: 'No File Selected'
	},
	methods : {
        vUpdateFileName: function () {
			//console.log(e,id);
			const fileInput = document.getElementById("at_file");
			if (fileInput.files.length > 0) {
				const fileName = document.getElementById('at_file_name');
				fileName.textContent = fileInput.files[0].name;
			}
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'fileupload');
		}
	}
});

var v_currently_selected_node = { node: G.root };

var vue_topnav = new Vue({
	el: '#v_topnav',
	data: { 
	   v: v_currently_selected_node,
	   iconBack: 'ico-left-arr-dis',
	   iconFwd: 'ico-right-arr-dis',
	},
	methods: {
		vSync: async function() {
			await fetchNodes(null,PROP_LASTMOD,'gt',_lastUpdateTime_Server,20);// _uids, _field = PROP_LASTMOD, _op = 'gt', _val = _lastUpdateTime_Server, _depth = 0
		},
		vNavBack: function() {
			navigateMainPaneBack();
			console.log('vNavBack');
		},
		vNavFwd: function() {
			navigateMainPaneForward();
			console.log('vNavFwd');
		},		
	}
});

var vue_topsearch = new Vue({
	el: '#v_topsearch',
	data: { 
	   v: v_currently_selected_node,
	   query: '',
	},
	methods: {
		vDoSearch: async function() {
			let queryObj = {query: this.query, node: this.v.node};
			await v_action_funcs['search'](queryObj, false);
			historyPush(HISTORY_SEARCH, queryObj);
		},
		
	}
});


////////////////////////////////////////////////////
//   resizable pane javascript
////////////////////////////////////////////////////

let isLeftDragging = false;
let isRightDragging = false;

function ResetColumnSizes() {
  // when page resizes return to default col sizes
  let page = document.getElementById("pageFrame");
  page.style.gridTemplateColumns = "2fr 6px 6fr";
}

function SetCursor(cursor) {
  let page = document.getElementById("page");
  page.style.cursor = cursor;
}

function StartLeftDrag() {
  // console.log("mouse down");
  isLeftDragging = true;

  SetCursor("ew-resize");
}

function StartRightDrag() {
  // console.log("mouse down");
  isRightDragging = true;

  SetCursor("ew-resize");
}

function EndDrag() {
  // console.log("mouse up");
  isLeftDragging = false;
  isRightDragging = false;

  SetCursor("auto");
}

function OnDrag(event) {
  if (isLeftDragging || isRightDragging) {

    let page = document.getElementById("page");
    let left_pane = document.getElementById("left_pane");

    let leftPaneWidth = isLeftDragging ? event.clientX : left_pane.clientWidth;

    let dragbarWidth = 6;

    let cols = [
      leftPaneWidth,
      dragbarWidth,
      page.clientWidth - dragbarWidth - leftPaneWidth,
    ];

    let newColDefn = cols.map(c => c.toString() + "px").join(" ");

    page.style.gridTemplateColumns = newColDefn;

    event.preventDefault()
  }
}


////////////////////////////////////////////////////
//   
////////////////////////////////////////////////////



fetchInitialNodes();

/*
const SLEEPINTERVAL = 60000; //millsec
var sleepTime = SLEEPINTERVAL;

setInterval( () => {
	let timeNow = Date.now();
	if(timeNow >=  (_lastUpdateTime_Browser + SLEEPINTERVAL)) {
		//console.log("refreshNodes()"); //
		refreshNodes();
		sleepTime = SLEEPINTERVAL;
	}
	else {
		sleepTime = (_lastUpdateTime_Browser + SLEEPINTERVAL) - timeNow;
	}
},sleepTime);
*/

</script>

</body></html>
