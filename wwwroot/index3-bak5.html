<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Page Title</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!--link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" /-->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Site Description Here" />
<link rel="stylesheet" href="bulma.min.css">
<link rel="stylesheet" href="quill.snow.css">
<!-- Include the JS libraries -->
<script src="quill.min.js"></script>
<script src="vue.min.js"></script>
<style>
@font-face {
  font-family: "archivo-regular";
  src: url("/Archivo-Regular.woff");
} 

body {
 font-family: archivo-regular;
}

.ctxmenu {
  cursor: context-menu;
  position: absolute;
  z-index: 100;
}
.ctxmenu li {
  padding-left: 0.25em;
  padding-right: 0.25em;
}
.ctxmenu li:hover{
	background: #aaaaaa;
	color: #eeeeee;
}

.ico-edit {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-edit-3'%3E%3Cpath d='M12 20h9'%3E%3C/path%3E%3Cpath d='M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z'%3E%3C/path%3E%3C/svg%3E");
  width: 1em;  
  height: 1em;
  margin-right: 1em;
}
.ico-del {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-x-circle'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='15' y1='9' x2='9' y2='15'%3E%3C/line%3E%3Cline x1='9' y1='9' x2='15' y2='15'%3E%3C/line%3E%3C/svg%3E");
  width: 1em;  
  height: 1em;
  margin-right: 1em;
}
.ico-new {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-file-plus'%3E%3Cpath d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'%3E%3C/path%3E%3Cpolyline points='14 2 14 8 20 8'%3E%3C/polyline%3E%3Cline x1='12' y1='18' x2='12' y2='12'%3E%3C/line%3E%3Cline x1='9' y1='15' x2='15' y2='15'%3E%3C/line%3E%3C/svg%3E");
  width: 1em;  
  height: 1em;
  margin-right: 1em;
}
.ico-left {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-arrow-left-circle'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 8 8 12 12 16'%3E%3C/polyline%3E%3Cline x1='16' y1='12' x2='8' y2='12'%3E%3C/line%3E%3C/svg%3E");
  width: 1em;  
  height: 1em;
  margin-right: 1em;
}

.ico-load {
  content: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjAiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHZpZXdCb3g9IjAgMCAxMjggMTI4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48Zz48cGF0aCBkPSJNNzEgMzkuMlYuNGE2My42IDYzLjYgMCAwIDEgMzMuOTYgMTQuNTdMNzcuNjggNDIuMjRhMjUuNTMgMjUuNTMgMCAwIDAtNi43LTMuMDN6IiBmaWxsPSIjMDAwIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoNDUgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoOTAgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iI2UxZTFlMSIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1IDY0IDY0KSIvPjxwYXRoIGQ9Ik03MSAzOS4yVi40YTYzLjYgNjMuNiAwIDAgMSAzMy45NiAxNC41N0w3Ny42OCA0Mi4yNGEyNS41MyAyNS41MyAwIDAgMC02LjctMy4wM3oiIGZpbGw9IiNiZWJlYmUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA2NCA2NCkiLz48cGF0aCBkPSJNNzEgMzkuMlYuNGE2My42IDYzLjYgMCAwIDEgMzMuOTYgMTQuNTdMNzcuNjggNDIuMjRhMjUuNTMgMjUuNTMgMCAwIDAtNi43LTMuMDN6IiBmaWxsPSIjOTc5Nzk3IiB0cmFuc2Zvcm09InJvdGF0ZSgyMjUgNjQgNjQpIi8+PHBhdGggZD0iTTcxIDM5LjJWLjRhNjMuNiA2My42IDAgMCAxIDMzLjk2IDE0LjU3TDc3LjY4IDQyLjI0YTI1LjUzIDI1LjUzIDAgMCAwLTYuNy0zLjAzeiIgZmlsbD0iIzZlNmU2ZSIgdHJhbnNmb3JtPSJyb3RhdGUoMjcwIDY0IDY0KSIvPjxwYXRoIGQ9Ik03MSAzOS4yVi40YTYzLjYgNjMuNiAwIDAgMSAzMy45NiAxNC41N0w3Ny42OCA0Mi4yNGEyNS41MyAyNS41MyAwIDAgMC02LjctMy4wM3oiIGZpbGw9IiMzYzNjM2MiIHRyYW5zZm9ybT0icm90YXRlKDMxNSA2NCA2NCkiLz48YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgdmFsdWVzPSIwIDY0IDY0OzQ1IDY0IDY0OzkwIDY0IDY0OzEzNSA2NCA2NDsxODAgNjQgNjQ7MjI1IDY0IDY0OzI3MCA2NCA2NDszMTUgNjQgNjQiIGNhbGNNb2RlPSJkaXNjcmV0ZSIgZHVyPSI3MjBtcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT48L2c+PGc+PGNpcmNsZSBmaWxsPSIjMDAwIiBjeD0iNjMuNjYiIGN5PSI2My4xNiIgcj0iMTIiLz48YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiBkdXI9IjcyMG1zIiBiZWdpbj0iMHMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBrZXlUaW1lcz0iMDswLjU7MSIgdmFsdWVzPSIxOzA7MSIvPjwvZz48L3N2Zz4=');
  width: 32px;  
  height: 32px;
}

.ico-logo {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-aperture'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='14.31' y1='8' x2='20.05' y2='17.94'%3E%3C/line%3E%3Cline x1='9.69' y1='8' x2='21.17' y2='8'%3E%3C/line%3E%3Cline x1='7.38' y1='12' x2='13.12' y2='2.06'%3E%3C/line%3E%3Cline x1='9.69' y1='16' x2='3.95' y2='6.06'%3E%3C/line%3E%3Cline x1='14.31' y1='16' x2='2.83' y2='16'%3E%3C/line%3E%3Cline x1='16.62' y1='12' x2='10.88' y2='21.94'%3E%3C/line%3E%3C/svg%3E");
  width: 32px;  
  height: 32px;
}

.ico-upload {
  content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-upload'%3E%3Cpath d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4'%3E%3C/path%3E%3Cpolyline points='17 8 12 3 7 8'%3E%3C/polyline%3E%3Cline x1='12' y1='3' x2='12' y2='15'%3E%3C/line%3E%3C/svg%3E");
  width: 32px;  
  height: 32px;
}

.ico-file2 {
content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-file-text'%3E%3Cpath d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'%3E%3C/path%3E%3Cpolyline points='14 2 14 8 20 8'%3E%3C/polyline%3E%3Cline x1='16' y1='13' x2='8' y2='13'%3E%3C/line%3E%3Cline x1='16' y1='17' x2='8' y2='17'%3E%3C/line%3E%3Cpolyline points='10 9 9 9 8 9'%3E%3C/polyline%3E%3C/svg%3E");
  width: 96px;  
  height: 96px;
}

.ico-sqminus {
content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-minus-square'%3E%3Crect x='3' y='3' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='8' y1='12' x2='16' y2='12'%3E%3C/line%3E%3C/svg%3E");
  width: 1em;  
  height: 1em; 
}

.ico-sqplus {
content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-plus-square'%3E%3Crect x='3' y='3' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='12' y1='8' x2='12' y2='16'%3E%3C/line%3E%3Cline x1='8' y1='12' x2='16' y2='12'%3E%3C/line%3E%3C/svg%3E");
  width: 1em;  
  height: 1em; 
}

.brk {
  word-wrap: anywhere;
}
.mono {
font-family: monospace;
white-space: pre-wrap;
white-space: -moz-pre-wrap;
white-space: -pre-wrap;
white-space: -o-pre-wrap;
word-wrap: anywhere;
}
.ptr {
 cursor: pointer;
}
.spacer5px {
 height: 5px;
}
.sidenavbar {
 height: 75vh;
 overflow-y: scroll;

}
.tooloutput {
 //height: 72vh;
 //overflow-y: scroll;
}
.mpprojects {
 //height: 68vh;
 //overflow-y: scroll;
}
.fullw {
 width: 100%;
}
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1; 
}
 
::-webkit-scrollbar-thumb {
  background: #888; 
}

::-webkit-scrollbar-thumb:hover {
  background: #555; 
}

/**********************************/
/*  draggable pane layout stuff   */
/**********************************/
#body_container {
  display: grid;
  height: 100vh;
  grid-template-columns: 1fr;
  grid-template-rows: min-content 1fr min-content;
  grid-template-areas:
        "header"
        "main"
        "footer";

}
#topnavbar {
  grid-area: header;
}
#pageFrame {
  grid-area: main;
    overflow: hidden;
}
#bottomnavbar {
  grid-area: footer;
}

#page {
  //height: 90vh;

  height: 100%;
  display: grid;
  grid-template-areas: 'left_pane dragbar right_pane';
  grid-template-rows: 10fr;
  grid-template-columns: 2fr 6px 6fr;
}

#left_pane {
 // overflow: auto;
  grid-area: left_pane;
   overflow-y: scroll;
	height: 100%;
}

#dragbar {
  background-color: grey;
  grid-area: dragbar;
  cursor: ew-resize;
}

#right_pane {
  //overflow: auto;
  grid-area: right_pane;
   overflow-y: scroll;
	height: 100%;
}

#modal_div {
//	  z-index: 100;
//	position: absolute;
//	top: 0px;
//	left: 0px;
}

</style>

    <!-- item template -->
    <template type="text/x-template" id="item-template">
      <li>
        <div :style="{textIndent: getIndent}" @contextmenu="showCtxMenu($event,item.uid)" >
		<span class="ptr" @click="viewNode($event,item.uid)">{{ item.l }}</span><!--{{ name() }}-->
          <!--span v-if="hasChildren" @click="toggle(item.uid)"-->
          <span v-if="item.out && item.out.length" @click="toggle(item.uid)">
		  <span v-if="isOpen"><img class="ico-sqminus"></span>
		  <span v-else><img class="ico-sqplus"></span>
		  </span>
        </div>
        <!--ul v-show="isOpen" v-if="hasChildren"-->
        <ul v-show="isOpen" v-if="item.outrefs && item.outrefs.length">
          <tree-item

            v-for="(child, index) in item.outrefs"
            :key="index"
            :item="child"
			:depth="depth+1"
            @make-folder="$emit('make-folder', $event)"
            @add-item="$emit('add-item', $event)"
          ></tree-item>
        </ul>
      </li>
    </template>

</head>
<body>
<div id="body_container" onclick="HideContextMenu()">

<!-- Context Menu Template -->
<!-- ??? programatically generate the options using v-for, v-if?? 
yes, can @click="juju($event,a.v)  where a is in data for the ctxmenu-div vue binding
-->

 <div id="ctxmenu-div" class="ctxmenu box has-background-light p-2" style="display: none">
   <ul id="v_ctxmenu">
    <li><b>Actions</b></li>
	<li v-for="optM in vdata.ctxmenuData.mainOptions" @click="ctxmenuAction($event,optM,vdata.ctxmenuData.uid)"><img class="ico-edit">{{optM}}</li>
	<li v-for="optA in vdata.ctxmenuData.addOptions" @click="ctxmenuAction($event,optA,vdata.ctxmenuData.uid)"><img class="ico-new">{{optA}}</li>
   </ul>
</div>

<!--
<template id="ctxmenu-templ">
 <div id="ctxmenu-div" class="ctxmenu box has-background-light p-2" style="display: none">
   <ul>
	<li @click="ctxmenuAction($event,'edit')"><img class="ico-edit">Edit Subgroup</li>
	<li @click="ctxmenuAction($event,'del')"><img class="ico-del">Delete Subgroup</li>
	<li @click="ctxmenuAction($event,'add')"><img class="ico-new">New Item</li>
   </ul>
 </div>
</template>
-->
<!-- top nav bar -->
<nav id="topnavbar" class="level box p-1">

  <!-- Left side -->
  <div class="level-left ml-3">
    <div class="level-item mr-1">
	<img id="id_logo" class="ico-logo" onClick="">
    </div>
    <div class="level-item">
      <p class="subtitle is-3 ptr" onClick="">
        <strong>Miruket</strong>
      </p>
    </div>
    <div class="level-item">
      <div class="field has-addons">
        <p class="control">
          <input class="input is-small" type="text" placeholder="Query the Data" disabled>
        </p>
        <p class="control">
          <button class="button is-small" disabled>
            Search
          </button>
        </p>
      </div>
    </div>
  </div>

  <!-- Right side -->
  <div id="v_topnav" class="level-right">
    <!--p class="level-item"><strong>All</strong></p-->
    <p class="level-item"><strong>{{v.node.l}}</strong></p>
    <!--p class="level-item pr-4" v-if="pr.ref.t"><strong>&nbsp;>>&emsp;{{pr.ref.t}}</strong></p>
	<p class="level-item pr-4" v-else><strong>&nbsp;</strong></p-->

    <p class="level-item"  onclick="toggleModal()"><a class="button is-small">Test Modal</a></p>
    <p class="level-item pr-4" onClick=""><a class="button is-small">Projects</a></p>
    <p class="level-item"><a @click="" class="button is-success is-small">Tasks</a></p>
  </div>

</nav>

<!-- columns view (tree + main panes) -->



<div id="pageFrame" onresize="ResetColumnSizes()">
  <div id="page" onmouseup="EndDrag()" onmousemove="OnDrag(event)">

    <div id="left_pane" class="pl-3 pr-3">
 	  <div id="tree_pane" class="">
		<ul id="v_tree_pane">
		  <ctxmenu></ctxmenu>
		  <tree-item
			:depth="0"
			:item="treeData.root"
			@make-folder="makeFolder"
			@add-item="addItem"
		  ></tree-item>
		</ul>
	  </div>
    </div>
	
    <div id="dragbar" onmousedown="StartLeftDrag()"></div>

    <div id="right_pane" class="pl-3 pr-3">
	 <div id="view_projbackup" class="box content is-medium" style="display: none">
		<!--////VueBinding////-->
		<!--
			<div id="v_view_projbackup">
				<h2>Welcome to Miruket</h2>
				<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>{{main_pane_tooloutput.body}}
				<div class="pb-3"><a class="button is-success is-medium" @click="vNewClient()">New Client</a></div>
				<p>Select a Client to See Projects</p>
				<div v-for="(cl, index) in mpd_clientlist.list">
				<span class="ptr" @click="vSelectClient(cl.uid)">&raquo; {{cl.t}}</span><span class="pl-2 ptr" @click="vEditClient(cl.uid)"><img class="ico-edit"></span>
				</div>
			</div>
			-->
		</div>

		<div id="view_default" class="box content" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_default">
				<h2>Pane for {{v.config.nodeinfo.l}}</h2>
				<div class="mpprojects">
					<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
					<div class="mono">{{v.config.nodeinfo.c}}</div>
					<p></p>
					<div class="pb-3"><a class="button is-success is-medium" @click="">New Project</a></div>
					<p>Select a Project from the List</p>
					<div v-for="(child, index) in v.config.nodeinfo.outrefs">
					<span class="ptr" @click="">{{child.uid}}&raquo; {{child.l}}</span><span class="pl-2 ptr" @click=""><img class="ico-edit"></span>
					</div>
				</div>
			</div>
		</div>
	 
		<div id="view_textbody" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_textbody">
				<h2>[{{v.config.nodeinfo.d}}] {{v.config.nodeinfo.l}}</h2>
				<!--is-family-monospace test1 -->
				  <div class="tooloutput"><div class="mono">{{v.config.nodeinfo.x}}</div></div>
				
			</div>
		</div>

		<div id="view_editor" style="display: none">
			<!--div id="editable_buttonbar" class="mb-2">
				<a class="button is-primary" id="toggleEditing" onclick="setQuillState('toggle')">Edit</a>
				<div class="field">
				  <div class="control"><input class="input is-info" type="text" placeholder="Info input"></div>
				</div>
			</div-->

				  <div class="columns is-vcentered">				
					<div class="column is-10">
					  <div class="field">
						<p class="control">
						  <input id="editor_title" class="input titleedit" type="text" placeholder="Enter a Note Title">
						</p>
					  </div>
					</div>
					
					<div id="v_view_editor" class="column is-2">
					  <a class="button is-primary" id="toggleEditing" onclick="toggleQuill()">Edit</a>
					</div>
					<!--div class="level-item">
					  <a class="button is-warning" id="canelEditing" onclick="">Cancel</a>
					</div-->
					
				  </div>
			
			<div id="editor" style="height: 65vh;"></div> 
		</div>
	 
		<div id="main_pane_testform" style="display: none">
		<!--////VueBinding////-->
		<!--
		 <div id="v_main_pane_testform">
			<h1 class="title">{{cl.action}} Details Form</h1>
			<div class="tooloutput">
			  <div class="pr-3">
				<div class="field">
				  <label class="label">Name</label>
				  <div class="control">
					<input class="input" type="text" placeholder="Client Short Name" v-model="cl.ref.t">
				  </div>
				</div>

				<div class="field">
				  <label class="label">Username</label>
				  <div class="control">
					<input class="input is-success" type="text" placeholder="Long Name or Description" v-model="cl.ref.d">
				  </div>
				  <p class="help is-success">This username is available</p>
				</div>

				<div class="field">
				  <label class="label">Subject</label>
				  <div class="control">
					<div class="select">
					  <select>
						<option>Select dropdown</option>
						<option>With options</option>
					  </select>
					</div>
				  </div>
				</div>

				<div class="field">
				  <label class="label">Message</label>
				  <div class="control">
					<textarea class="textarea" placeholder="Textarea"></textarea>
				  </div>
				</div>

				<div class="field">
				  <div class="control">
					<label class="checkbox">
					  <input type="checkbox">
					  I agree to the <a href="#">terms and conditions</a>
					</label>
				  </div>
				</div>

				<div class="field">
				  <div class="control">
					<label class="radio">
					  <input type="radio" name="question">
					  Yes
					</label>
					<label class="radio">
					  <input type="radio" name="question">
					  No
					</label>
				  </div>
				</div>

				<div class="field is-grouped">
				  <div class="control">
					<button class="button is-link" @click="vSubmit()">Submit</button>
				  </div>
				  <div class="control">
					<button class="button is-link is-light">Cancel</button>
				  </div>
				</div>
				
			  </div>
			</div>
		 </div>  
		 -->
		</div><!-- end main_pane -->
	 
	 
		<div id="edit_default" style="display: none">
		<!--////VueBinding////-->
		 <div id="v_edit_default">
			<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Short Name</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>

				<div class="field">
				  <label class="label">Description</label><div class="control"><input class="input is-success" type="text" placeholder="Client Full Name or Description" v-model="v.config.nodeinfo.d"></div>
				</div>

				<div class="field">
				  <label class="label">Notes</label><div class="control"><textarea class="textarea" placeholder="Client notes area" v-model="v.config.nodeinfo.c"></textarea></div>
				</div>

				<div class="field is-grouped">
				  <div class="control"><button class="button is-link" @click="vSubmit()">Save</button></div>
				  <div class="control"><button class="button is-link is-light">Cancel</button></div>
				</div>
				
			  </div>
			</div>
		 </div>
		</div><!-- end main_pane -->



	 
		<div id="view_download" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_download">
				<h2>{{v.config.nodeinfo.l}}</h2>
				<div class="tooloutput">
					<div v-if="v.config.nodeinfo.d.startsWith('image/')">
					<img :src="'/download/'+v.config.nodeinfo.uid" id="imgview" class="ptr" @click="vOpenNewWindow('/download/'+v.config.nodeinfo.uid)">
					</div>
					<div v-else>
					<h3>Download</h3>
					<p>
					<span class="ptr" @click="vOpenNewWindow('/download/'+v.config.nodeinfo.uid)">
					<img class="ico-file2"><br>
					{{v.config.nodeinfo.l}}</span>
					<br>({{v.config.nodeinfo.d}})
					</p>
					</div>
				</div>
			</div>
		</div>

	 
		<div id="view_image" class="box content is-small" style="display: none">
		<!--////VueBinding////-->
			<div id="v_view_image">
				<h2>{{v.config.nodeinfo.l}}</h2>
				<div class="tooloutput">
					<div v-if="v.config.nodeinfo.d.startsWith('image/')">
					<img :src="'/download/'+v.config.nodeinfo.uid" id="imgview" class="ptr" onclick="toggleImgFullscreen()">
					</div>
					<div v-else>
					<h3>Download</h3>
					<p>
					<a :href="'/download/'+v.config.nodeinfo.uid">
					<img class="ico-file2"><br>
					{{v.config.nodeinfo.l}}</a>
					<br>({{v.config.nodeinfo.d}})
					</p>
					</div>
				</div>
			</div>
		</div>
		
		
		
    </div><!--end right_pane-->

  </div>
</div>





<div id="graph_layout"></div>

<!--footer-->
<nav id="bottomnavbar" class="level box p-1">

  <!-- Left side -->
  <div class="level-left ml-3">
    <div class="level-item mr-1">
		Placeholder
    </div>
    <div class="level-item">
      <p class="subtitle is-7 ptr" onClick="">
        <strong>Test</strong>
      </p>
    </div>
    <div class="level-item">
    </div>
  </div>

  <!-- Right side -->
  <div id="v_bottomnav" class="level-right">
    <p class="level-item"><strong>{{v.node.l}}</strong></p>
  </div>

</nav>






</div><!--body_container-->


<!--Modal Display-->
<div id="modal_div" class="modal">
  <div class="modal-background"></div>
  <div class="modal-card">


    <!--div for modal pane-->
	<div id="add_fileupload" style="display: none">
	 <div id="v_add_fileupload"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Title</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
			<div class="file has-name">
			  <label class="file-label">
				<input class="file-input" type="file" id="at_file" @change="vUpdateFileName()" name="upload">
				<span class="file-cta">
				  <span class="file-icon">
					<img class="ico-upload">
				  </span>
				  <span class="file-label">
					Choose a file…
				  </span>
				</span>
				<span class="file-name" id="at_file_name">
				  {{filename}}
				</span>
			  </label>
			</div>

		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Save changes</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->




    <!--div for modal pane-->
	<div id="add_default" style="display: block">
	 <div id="v_add_default"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Title</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
	  		<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Short Name</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>

				<div class="field">
				  <label class="label">Description</label><div class="control"><input class="input is-success" type="text" placeholder="Client Full Name or Description" v-model="v.config.nodeinfo.d"></div>
				</div>

				<div class="field">
				  <label class="label">Notes</label><div class="control"><textarea class="textarea" placeholder="Client notes area" v-model="v.config.nodeinfo.c"></textarea></div>
				</div>

			  </div>
			</div>
		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Save changes</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->	




    <!--div for modal pane-->
	<div id="add_editor" style="display: block">
	 <div id="v_add_editor"><!--bind Vue to this div-->
		<header class="modal-card-head">
		  <p id="modal_title" class="modal-card-title">Title</p>
		  <button class="delete" onclick="toggleModal()" aria-label="close"></button>
		</header>

		<section class="modal-card-body">
	  		<h1 class="title">{{v.config.title}}</h1>
			<div class="tooloutput">
			  <div class="pr-3">
			  
				<div class="field">
				  <label class="label">Short Name</label><div class="control"><input class="input" type="text" placeholder="Client Short Name" v-model="v.config.nodeinfo.l"></div>
				</div>
				
			  </div>
			</div>
		</section>
		
		<footer class="modal-card-foot">
		  <button class="button is-success" @click="vSubmit()">Save changes</button>
		  <button class="button" onclick="toggleModal()">Cancel</button>
		</footer>
	 </div>
    </div><!--end modal pane-->	




	
  <button onclick="toggleModal()" class="modal-close is-large" aria-label="close"></button>
 </div>
</div><!--end modal div-->	


<div id="testdiv" style="background-color: green; width: 50%; height: 50%; position: absolute; top: 100px; left: 100px; display: none">
test
</div>

<script>
// script begin --------------------------------------------------------------------------------------------------------

function toggleImgFullscreen() {
  let elem = document.getElementById("imgview");

  if (!document.fullscreenElement) {
    elem.requestFullscreen().catch(err => {
      alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
    });
  } else {
    document.exitFullscreen();
  }
}

function openNewWindow(url) {
  var win = window.open(url, '_blank');
  win.focus();
}

//Initialize Quill editor

var toolbarOptions = [
  ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
  ['blockquote', 'code-block'],

  [{ 'header': 1 }, { 'header': 2 }],               // custom button values
  [{ 'list': 'ordered'}, { 'list': 'bullet' }],
  [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript
  [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent
  [{ 'direction': 'rtl' }],                         // text direction

  [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
  [{ 'header': [1, 2, 3, 4, 5, 6, false] }],

  [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
  [{ 'font': [] }],
  [{ 'align': [] }],
  ['image'],
  ['video'],
  ['clean']                                         // remove formatting button
];

var quill = new Quill('#editor', {
  modules: {
    toolbar: toolbarOptions
  },
  theme: 'snow'
});
quill.disable();


var quillCurrentUid = '';

function toggleQuill()
{
	let isEnabled = quill.isEnabled();
	if(isEnabled)
		_panesIndex['edit']['editor'].onAfterSubmit();
	else
		//_panesIndex['edit']['editor'].onBeforeShow();		
		v_action_funcs['edit'](quillCurrentUid);
}

function populateQuill(nodeinfo)
{
	// load stuff from vPtrAttach
	// serializedDelta can be stored in persistent storage or sent in a message etc.
	let serialisedDeltas = nodeinfo[PROP_TEXTDATA] ||  "{}";
	quill.setContents(JSON.parse(serialisedDeltas));	
	let edtitle = document.getElementById('editor_title');
	edtitle.value = nodeinfo[PROP_LABEL];
}

function getQuillEdits(nodeinfo)
{
	let edtitle = document.getElementById('editor_title');
	let deltas = quill.getContents();
	nodeinfo[PROP_TEXTDATA] = JSON.stringify(deltas);
	//attNode[] = MIME_MIRUKET_NOTE;
	nodeinfo[PROP_LABEL] = edtitle.value;
	//vPtrAttach.ref.t = 'Untitled Note';
	nodeinfo[PROP_DETAIL] = 'Note';
}

function setQuillVisualState(status)
{
	let edbutton = document.getElementById('toggleEditing');
	let edtitle = document.getElementById('editor_title');

	if(status == 'enable') {
		quill.enable();
		edtitle.readOnly = false;
		edbutton.innerText = "Save";
	}
	else {
		quill.disable();
		edtitle.readOnly = true;
		edbutton.innerText = "Edit";
	}

}


// data stores ------------------------------------------------------------
const TYPE_ROOT = "__ROOT__";
const PROP_UID = "uid";
const PROP_TYPE = "ty";
const PROP_LABEL = "l";
const PROP_DETAIL = "d";
const PROP_TEXTDATA = "x";
const PROP_CUSTOM = "c";
const PROP_TIME = "t";
const PROP_LASTMOD = "m";
const PROP_BINARYDATA = "b";
const PROP_EDITING = "e";
const PROP_PARENTLIST = "in";
const PROP_CHILDLIST = "out";
const PROP_RELATIONS = "lnk";
const PROP_PARENTREFS = "inrefs";
const PROP_CHILDREFS = "outrefs";

function emptyNode(_uid = '', type = '') { 
	//return { uid: _uid, l: '', d: '', e: '', ty: type, c: '', x: '', b: '', t: '', m: '', inrefs : [], outrefs : [], in: [], out: [], lnk: [], hasChanged: false, isOpen: false}
	let node = {};
	node[PROP_UID] = _uid;
	node[PROP_TYPE] = type;
	node[PROP_LABEL] = '';
	node[PROP_DETAIL] = '';
	node[PROP_TEXTDATA] = '';
	node[PROP_CUSTOM] = '';
	node[PROP_TIME] = '';
	node[PROP_LASTMOD] = '';
	node[PROP_BINARYDATA] = '';
	node[PROP_EDITING] = '';
	node[PROP_PARENTLIST] = [];
	node[PROP_CHILDLIST] = [];
	node[PROP_PARENTREFS] = [];
	node[PROP_CHILDREFS] = [];
	node[PROP_RELATIONS] = [];
	node.hasChanged = false;
	node.isOpen = false;
	return node;
};

var _root = emptyNode('.',TYPE_ROOT);
var _index = {};
var G = { root : _root , ctxmenuData: emptyCtxMenuData()};

_index[_root.uid] = _root;
_root.l = "All Categories";


var _defaultPaneConfigs = {
	//main_pane is the target for these:
	view: {
		//key : function to return config obj
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible
				label: { visible: true, name: "Label" },
				detail: { visible: true, name: "Detail" },
				custom: { visible: true, name: "Custom Data" },
				textdata: { visible: true, name: "Text Data" },
				eventtime: { visible: true, name: "Event Time" },
				title: '',
			};
		},
	},
	edit: {
		//key : DOMelementID
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible, editable, and its label
				label: { visible: true, editable: true, name: "Label", required: true },
				detail: { visible: true, editable: true, name: "Detail", required: true },
				custom: { visible: true, editable: true, name: "Custom Data", required: false },
				textdata: { visible: true, editable: true, name: "Text Data", required: false },
				eventtime: { visible: true, editable: true, name: "Event Time", required: false },
				title: '',
			};
		},
	},
	//modal is the target for these:
	add: {
		//key : DOMelementID
		"default" : function() {
			return {
				//indicating whether corresponding node property will be visible, editable, and its label
				label: { visible: true, editable: true, name: "Label", required: true },
				detail: { visible: true, editable: true, name: "Detail", required: true },
				custom: { visible: true, editable: true, name: "Custom Data", required: false },
				textdata: { visible: true, editable: true, name: "Text Data", required: false },
				eventtime: { visible: true, editable: true, name: "Event Time", required: false },
				title: '',
			};
		},
	},
	moveparent:  {
		//key : DOMelementID
		"default" : function() { return {} },
	},
	movechildren: {
		//key : DOMelementID
		"default" : function() { return {} },
	}
};

function getDefaultConfig(panetype, subtype = 'default')
{
	let conf = _defaultPaneConfigs[panetype][subtype]();
	if(!conf) conf = {};
	conf.nodeinfo = emptyNode();
	return conf;
	//conf.parentNodeID = ''; the nodeinfo contains parents
}

var _typeConfigs = {};

let rootConfig = 
 {
		typesAllowedForChildNodes : new Set(),
		actionViewConf: { paneType: "default", config: getDefaultConfig('view') },
		actionAddConf: { paneType: "default", config: getDefaultConfig('add') },
		actionEditConf: { paneType: "default", config: getDefaultConfig('edit') },
}


_typeConfigs[TYPE_ROOT] = rootConfig;

function createTypeConfigWithDefaults(
	typename,
	listOfAllowedChildren = [], 
	canAddToTopLevel = true,
	view = 'default', 
	add = 'default', 
	edit = 'default', 
	moveparent = 'default', 
	movechildren = 'default') {

	let newTC = {};
	newTC.typesAllowedForChildNodes = new Set(listOfAllowedChildren);
	newTC.actionViewConf = (view) ? { paneType: view, config: getDefaultConfig('view') } : null;
	newTC.actionAddConf = (add) ? { paneType: add, config: getDefaultConfig('add') } : null;
	newTC.actionEditConf = (edit) ? { paneType: edit, config: getDefaultConfig('edit') } : null;
	newTC.actionMoveParentConf = (moveparent) ? { paneType: "default", config: {} } : null;
	newTC.actionMoveChildrenConf = (movechildren) ? { paneType: "default", config: {} } : null;

	if(canAddToTopLevel) 
		rootConfig.typesAllowedForChildNodes.add(typename);
	_typeConfigs[typename] = newTC;
	return newTC;

}

/*
	return {
		typesAllowedForChildNodes : new Set(listOfAllowedChildren),
		actionViewConf: { paneType: "default", config: getDefaultConfig('view') },
		actionAddConf: { paneType: "default", config: getDefaultConfig('add') },
		actionEditConf: { paneType: "default", config: getDefaultConfig('edit') },
		actionMoveParentConf: { paneType: "default", config: {} },
		actionMoveChildrenConf: { paneType: "default", config: {} },
	}
*/


createTypeConfigWithDefaults('unknown',[],false);



// when adding a type to the app, have to configure it here, plus add it to ctxmenu and 


/*
TYPE_CLIENT

_typeConfigs["foobar"] = {
		typesAllowedForChildNodes : new Set(["typeA","typeB"]),
		actionViewConf: { paneType: "default", config: {...} },
		...
	}
_typeConfigs[TYPE_ROOT].typesAllowedForChildNodes.add("foobar");

*/
const TYPE_CLIENT = "Client";
const TYPE_PROJECT = "Project";
const TYPE_FOLDER = "Folder";
const TYPE_HOST = "Host";
const TYPE_PORT = "Port";
const TYPE_TEXT = "Text";
const TYPE_IMAGE = "Image";
const TYPE_FILE = "File";
const TYPE_NOTE = "Note";
const TYPE_ANNOTATION = "Annotation";
const TYPE_TAG = "Tag";
const TYPE_REPORT = "Report";
const TYPE_SECTION = "Section";
const TYPE_FINDING = "Finding";

createTypeConfigWithDefaults(TYPE_CLIENT, [TYPE_FOLDER, TYPE_PROJECT, TYPE_NOTE, TYPE_ANNOTATION, TYPE_FILE]);
createTypeConfigWithDefaults(TYPE_PROJECT, [TYPE_FOLDER, TYPE_REPORT, TYPE_NOTE, TYPE_TEXT, TYPE_IMAGE, TYPE_ANNOTATION, TYPE_FILE],false);
createTypeConfigWithDefaults(TYPE_FOLDER, [TYPE_FOLDER, TYPE_CLIENT, TYPE_PROJECT, TYPE_NOTE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE, TYPE_IMAGE, TYPE_TAG, TYPE_HOST, TYPE_PORT, TYPE_REPORT, TYPE_SECTION, TYPE_FINDING]);
createTypeConfigWithDefaults(TYPE_HOST, [TYPE_FOLDER, TYPE_PORT, TYPE_IMAGE, TYPE_TEXT, TYPE_NOTE, TYPE_ANNOTATION, TYPE_FILE],false);
createTypeConfigWithDefaults(TYPE_PORT, [TYPE_FOLDER, TYPE_PROJECT, TYPE_NOTE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE],false);
createTypeConfigWithDefaults(TYPE_TEXT, [TYPE_ANNOTATION],false,'textbody',null,null);
createTypeConfigWithDefaults(TYPE_IMAGE, [TYPE_ANNOTATION],false,'download','fileupload',null);
createTypeConfigWithDefaults(TYPE_FILE, [TYPE_ANNOTATION],false,'download','fileupload',null);
createTypeConfigWithDefaults(TYPE_NOTE, [TYPE_ANNOTATION],false,'editor','editor','editor');
createTypeConfigWithDefaults(TYPE_ANNOTATION, [],false,null,null,'default');
createTypeConfigWithDefaults(TYPE_TAG, [TYPE_FOLDER, TYPE_CLIENT, TYPE_PROJECT, TYPE_NOTE, TYPE_TEXT, TYPE_ANNOTATION, TYPE_FILE, TYPE_IMAGE, TYPE_TAG, TYPE_HOST, TYPE_PORT, TYPE_REPORT, TYPE_SECTION, TYPE_FINDING],false);
createTypeConfigWithDefaults(TYPE_REPORT, [TYPE_FOLDER, TYPE_SECTION, TYPE_NOTE, TYPE_ANNOTATION, TYPE_FILE, TYPE_TEXT, TYPE_IMAGE],false);
createTypeConfigWithDefaults(TYPE_SECTION, [TYPE_FINDING, TYPE_SECTION, TYPE_NOTE, TYPE_ANNOTATION, TYPE_FILE, TYPE_TEXT, TYPE_IMAGE],false);
createTypeConfigWithDefaults(TYPE_FINDING, [TYPE_FOLDER, TYPE_NOTE, TYPE_ANNOTATION, TYPE_FILE, TYPE_TEXT, TYPE_IMAGE],false);


//write a loop that iterates thru all typeConfigs and checks whether its members contain config.nodeinfo
//if not, create an empty node.... or maybe just force set it???

function setNodeInfo(typeConfObj, actionConf)
{
	if(typeConfObj[actionConf] && typeConfObj[actionConf].config && !typeConfObj[actionConf].config.nodeinfo) 
		typeConfObj[actionConf].config.nodeinfo = emptyNode();
}

for (const [key, value] of Object.entries(_typeConfigs)) {
	console.log(`${key}: ${value}`);
	setNodeInfo(value, 'actionViewConf');
	setNodeInfo(value, 'actionEditConf');
	setNodeInfo(value, 'actionAddConf');
	setNodeInfo(value, 'actionMoveParentConf');
	setNodeInfo(value, 'actionMoveChildrenConf');
}

///****************** Move Vue bindings here, and the panesIndex will bind to their data.v objects 
// eg. v_editAndView_editor.$data.v
// eg. v_editAndView_editor.$root.testEventHandler
// and not... 
// the vue objects will bind to paneConfig

var _panesIndex = {
	//main_pane divs:
	view: {
		//pane key 
		"default" : {
			divID: "view_default", //DOMelementID
			v: { config: getDefaultConfig('view')},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		//todo: file, image, text, note, annotation(nothing), folder(?)
		"download" : {
			divID: "view_download", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		"textbody" : {
			divID: "view_textbody", //DOMelementID
			v: { config:  getDefaultConfig('view')},
			onBeforeShow: function(){}, //get config using this.v.config  (will have nodeinfo and parentID)
		},
		"editor" : {
			divID: "view_editor", //DOMelementID
			v: { config:  getDefaultConfig('view')},
//			onBeforeShow: function(){
			onBeforeShow: async function(){
				//need to fetch attachment body and populate quill
//				updateAttachmentNodeIfChangedOrEmpty(this.v.config.nodeinfo);
				let nodeInfo = this.v.config.nodeinfo;
				await updateAttachmentNodeIfChangedOrEmpty(nodeInfo);
				populateQuill(nodeInfo);
				setQuillVisualState("disable");
				quillCurrentUid = nodeInfo[PROP_UID];
			}, //get config using this.v.config  (will have nodeinfo and parentID)
		},

	},
	// for edit panetypes:
	// onBeforeCopyNode() paneConfig.nodeinfo contains the original node, to allow actions on it to occur
	// onBeforeShow()  paneConfig.nodeinfo contains a copy of the node, run before pane is shown
	// onAfterSubmit() paneConfig.nodeinfo contains a copy of the node, run after submitAction button is clicked (put upsert request in here)
	edit: {
		"default" : {
			divID: "edit_default",
			v: { config:  getDefaultConfig('edit')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){ await upsertGeneric(this.v.config.nodeinfo); },
			},
		"editor" : {
			divID: "view_editor",
			v: { config:  getDefaultConfig('edit')},
			onBeforeCopyNode: async function(){
				//need to fetch attachment body if its not there or needs an update
				await updateAttachmentNodeIfChangedOrEmpty(this.v.config.nodeinfo);
				// the above operation will update the _index, but that's not 
			}, //get config using this.v.config  (will have nodeinfo and parentID)
			onBeforeShow: function(){
				populateQuill(this.v.config.nodeinfo);
				setQuillVisualState("enable");
			},
			onAfterSubmit: async function(){
				let nodeInf = this.v.config.nodeinfo;
				getQuillEdits(nodeInf);
				let x_changed = (nodeInf[PROP_TEXTDATA] != _index[nodeInf[PROP_UID]][PROP_TEXTDATA]);
				let l_changed = (nodeInf[PROP_LABEL] != _index[nodeInf[PROP_UID]][PROP_LABEL]);
				if(!x_changed)
					nodeInf[PROP_TEXTDATA] = null;
				if(x_changed || l_changed)
					await upsertGeneric(nodeInf);
				setQuillVisualState("disable");
				quillCurrentUid = nodeInf[PROP_UID];
			},
		},
	},
	//modal divs:
	add: {
		"default" : {
			divID: "add_default",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){ await upsertGeneric(this.v.config.nodeinfo); },
			},
		//todo: file, image, text, note, annotation, folder
		"fileupload" : {
			divID: "add_fileupload",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){clearFileUploadFormInput();},
			onAfterSubmit: async function(){ await fileupload(this.v.config.nodeinfo);},
			},
		"editor" : { //we show a dialog to enter the note name, create the empty note and show the actual editor
			divID: "add_editor",
			v: { config:  getDefaultConfig('add')},
			onBeforeShow: function(){},
			onAfterSubmit: async function(){
				let ninfo = this.v.config.nodeinfo;
				await upsertGeneric(ninfo); 
				v_action_funcs['edit'](ninfo[PROP_UID]);
				},
			},

	},
	moveparent:  {
		"default" : {},
	},
	movechildren: {
		"default" : {},
	}
};




// show/hide the main panes -------------------------------------------------

const D_HIDE = "none";
const D_SHOW = "block";

function getPaneDivs(panesOfType, outDict)
{
	for (const [key, value] of Object.entries(panesOfType)) {
		//console.log(`${key}: ${value}`);
		let div = document.getElementById(value.divID);
		if(div)
			outDict[value.divID] = div;
	}
}

var mainPaneDivLookup = {};
var modalPaneDivLookup = {};

getPaneDivs(_panesIndex.view,mainPaneDivLookup);
getPaneDivs(_panesIndex.edit,mainPaneDivLookup);
getPaneDivs(_panesIndex.add,modalPaneDivLookup);
getPaneDivs(_panesIndex.moveparent,modalPaneDivLookup);
getPaneDivs(_panesIndex.movechildren,modalPaneDivLookup);


function switchPane(paneType, paneName)
{
	let _divID = _panesIndex[paneType][paneName].divID;
	
	//main_pane divs
	if(paneType == 'view' || paneType == 'edit')
	{
		for (const [key, value] of Object.entries(mainPaneDivLookup))
			value.style.display = (key == _divID) ? D_SHOW : D_HIDE;
	}
	else
	//modal divs
	{
		for (const [key, value] of Object.entries(modalPaneDivLookup))
			value.style.display = (key == _divID) ? D_SHOW : D_HIDE;
		// show the modal div
		toggleModal();
		//document.getElementById("modal_div").classList.toggle('is-active');
	}
}

// event handlers ------------------------------------------------------------

function HideContextMenu(){
	document.getElementById("ctxmenu-div").style.display = "none";
}

function showLoading(waiting)
{
  let elem = document.getElementById("body_container");
  elem.style.cursor = (waiting) ? "wait" : "auto";
  let logo = document.getElementById("id_logo");
  if(waiting)
	logo.classList.replace('ico-logo', 'ico-load');
  else
	logo.classList.replace('ico-load', 'ico-logo');
}

/*
const fileInput = document.getElementById("at_file");
  fileInput.onchange = () => {
    if (fileInput.files.length > 0) {
      const fileName = document.getElementById('at_file_name');
      fileName.textContent = fileInput.files[0].name;
    }
  };
*/



function toggleModal()
{
   document.getElementById("modal_div").classList.toggle('is-active');
   //let div = document.getElementById("testdiv");
   //div.style.display = (div.style.display == D_HIDE) ? D_SHOW : D_HIDE;
}

function clearFileUploadFormInput()
{
	const fileName = document.getElementById('at_file_name');
      fileName.textContent = 'No File Selected';
}

function serialise(jsonObj) {
    return JSON.stringify(jsonObj, (key,value) =>
	{
		if (key==PROP_PARENTREFS || key==PROP_CHILDREFS || key==PROP_LASTMOD) return undefined;
		//should nullify certain values that are '' eg. t, x, e, c
		if ((key==PROP_TEXTDATA || key==PROP_BINARYDATA || key==PROP_TIME || key==PROP_EDITING || key==PROP_TYPE) && value == '') return undefined;
		else return value;
	} );
}

function clearList(list)
{
	if(list)
		while(list.length > 0)
			list.pop()
}

function clearObjectProperties(obj)
{
	for (var prop in obj) {
		if (obj.hasOwnProperty(prop)) {
			delete obj[prop];
		}
	}
}

const ip_rgx = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/

function convertIPtoNum(ipstr) {
  let octs = ipstr.split('.');
  return (octs[0] * 16777216.0) + (octs[1] * 65536.0) + (octs[2] * 256.0) + octs[3] * 1.0;
}


//genericUpsert
//this should be modified to return a result to indicate whether error or success
// the result can be interpreted by the 'add' dialog so an error can be shown or the dialog closed if successful
async function upsertGeneric(node)
{	
	showLoading(true);
	console.log("upsert: ",serialise(node));
	await fetch('upsert',{
		method: 'POST',
		headers: {
		  'Content-Type': 'application/json'
		},
		body: '['+serialise(node)+']' // body data type must match "Content-Type" header
	})
	.then(response => response.json())
	.then(rdata => { 
		console.log(JSON.stringify(rdata));
		if(rdata && rdata.length > 0)
		{
			if(!_index[rdata[0]])
				_index[rdata[0]] = emptyNode(rdata[0]);
			//refreshQuery()
		}
		else
		{
			console.log("an error occurred when attempting to upsert node");//deal with the error
		}
	});
	showLoading(false);

	await refreshNodes();
}


//fileupload
async function fileupload(node)
{
	const input = document.getElementById('at_file');

	let params = {};
	if(node[PROP_UID])
		params.attachid = node[PROP_UID];
	params.parentid = node[PROP_PARENTLIST][0].uid;
	
	let data = new FormData();
	data.append('filedata', input.files[0]);
	data.append('type', 'file_upload');
	data.append('_p', JSON.stringify(params));

	await fetch('upload', {
	  method: 'POST',
	  //mode: 'no-cors', //for testing with httpbin
	  //!!important: don't set the content-type
	  body: data
	  }).then(response => response.text()).then( response => {
			console.log(response);
			if(response.startsWith('0x'))
			{
				_index[response] = emptyNode(response);
			}
		});//.then(rdata => { console.log(JSON.stringify(rdata)); }
	//);
	
	await refreshNodes();
}
//updatenodes (send list of uids to server and get nodes (newer than last update)
// create inrefs, outrefs, isOpen
var _lastProjTreeUpdateTime = 0;

function getUidsFromIndex()
{
	let listOfUids = [];
	for (const [key, value] of Object.entries(_index)) {
		listOfUids.push(key);
	}
	return listOfUids;
}

async function fetchChildNodes(nodeid)
{
	//check if nodeid has outrefs, if it doesn't then:
	let node = _index[nodeid];
	if( node && (node[PROP_CHILDREFS].length < 1))
		await fetchNodes([nodeid],PROP_LASTMOD,'gt',0,1);
}

async function refreshNodes()
{
	await fetchNodes(getUidsFromIndex());
}

async function fetchInitialNodes()
{
	_lastProjTreeUpdateTime = 0;
	//this will fetch only the root node:
	await fetchNodes(null,PROP_LASTMOD,'gt',0,0);
	//there should be only two nodes in the index after this initial request:
	// _index['.'] (the placeholder for root node)
	// _index['0xN'] (the actual root node
	for (const [key, value] of Object.entries(_index)) {
		if(key != '.') {
			//G.root = value;
			updateNode(G.root,value);
			createEdgesForNode(G.root);
			delete _index['.'];
			_index[G.root[PROP_UID]] = G.root;
		}
	}
	await fetchChildNodes(G.root.uid,0);
}

async function fetchNodes(_uids, _field = PROP_LASTMOD, _op = 'gt', _val = _lastProjTreeUpdateTime, _depth = 0)
{
//  /nodes POST
//  { field=m op='gt' val=_lastProjTreeUpdateTime depth=0
//   uids = [] }
	let data = { field: _field, op: _op, val: `${_val}`, depth: _depth, uids: _uids };
	showLoading(true);
console.log('A'+JSON.stringify(data));
	await fetch('/nodes', {
		method: 'POST',
		//mode: 'no-cors', //for testing with httpbin
		headers: {
		  'Content-Type': 'application/json'
		},
		body: JSON.stringify(data)
	}).then(response => response.json() )
	.then(rdata => { 
		console.log(JSON.stringify(rdata));
		if(rdata && rdata.nodes && !rdata.error)
		{
			updateNodeTree(rdata);
		}
		else
		{
			console.log("update nodes failed: ",rdata.message);//deal with the error
		}
	});//.catch(console.log("update nodes failed: caught exception."));
	showLoading(false);	
}

function createEdgesFromUids(listUidObjs)
{
	let tmpList = [];
	if(listUidObjs)
		listUidObjs.forEach(uidobj => {
			if(_index[uidobj.uid]) 
				tmpList.push(_index[uidobj.uid]);
		});
	return tmpList;
}

function createEdgesFromUidsInplace(listUidObjs,existingList)
{
	if(listUidObjs)
		listUidObjs.forEach(uidobj => {
			if(_index[uidobj.uid]) 
				existingList.push(_index[uidobj.uid]);
		});
}

function createEdgesForNode(node)
{
//root node doesn't have parentrefs, what to do?
		clearList(node[PROP_PARENTREFS]);
		createEdgesFromUidsInplace(node[PROP_PARENTLIST],node[PROP_PARENTREFS]);

//	node[PROP_PARENTREFS] = createEdgesFromUids(node[PROP_PARENTLIST]);
		clearList(node[PROP_CHILDREFS]);
		createEdgesFromUidsInplace(node[PROP_CHILDLIST],node[PROP_CHILDREFS]);

//	node[PROP_CHILDREFS] = createEdgesFromUids(node[PROP_CHILDLIST]);
}

function updateNode(existingNode, updatedNode)
{
	existingNode.hasChanged = (updatedNode[PROP_LASTMOD] != existingNode[PROP_LASTMOD]); 
	for (const [key, value] of Object.entries(updatedNode)) {
	  existingNode[key] = value;
	  //console.log("update:",key,value);
	}
}

function updateNodeTree(serverResponse)
{
	// delete nodes
	// delete edges
	// upsert nodes

	let nodes = serverResponse.nodes;
	for (let i = 0; i < nodes.length; i++)
	{
		//  if exists in mainindex then update
		let node = nodes[i];
		let tnode = _index[node.uid];

		if(tnode)
			updateNode(tnode, node);
		else
		{
			node.hasChanged = true;
			node.isOpen = false;
			node[PROP_PARENTLIST] = node[PROP_PARENTLIST] || [];
			node[PROP_PARENTREFS] = node[PROP_PARENTREFS] || [];
			node[PROP_CHILDLIST] = node[PROP_CHILDLIST] || [];
			node[PROP_CHILDREFS] = node[PROP_CHILDREFS] || [];
			node[PROP_RELATIONS] = node[PROP_RELATIONS] || [];
			_index[node.uid] = node;
			tnode = node;
			//console.log("add main:",tnode.uid);
		}
	}

	for (let i = 0; i < nodes.length; i++)	
		createEdgesForNode(_index[nodes[i].uid]);

	_lastProjTreeUpdateTime = serverResponse.timestamp;
	//vue_col_groups.$forceUpdate();
}

async function updateAttachmentNodeIfChangedOrEmpty(node,datafield = PROP_TEXTDATA)
{
	if(node.hasChanged || !node[datafield])
	{
console.log("att refresh: ",node.m);
		showLoading(true);
//		await fetch('/attachment/'+node[PROP_UID]+'/'+(!node[datafield] ? '0' : _lastProjTreeUpdateTime))
		await fetch('/attachment/'+node[PROP_UID]+'/0')
		.then(response => response.json())
			.then(data => { 
				//vPtrAttach.ref.b = data.nodes[0].b;
				updateNodeTree(data);
				//vPtrAttach.ref = _index[aID];
				//vPtrAttach.parentID = _index[aID].in[0].uid;
				}
			);
		showLoading(false);
		//node.hasChanged = false;
		//vPtrAttach.ref = _index[aID];
		//vue_mp_showfile.$forceUpdate();
	}
	else {console.log("att hasnt changed or already has datafield: ",node.hasChanged,node[datafield]);}
}


/////////////////////////////////////////////////////////////////////////////////////////
//     VueJS Bindings
/////////////////////////////////////////////////////////////////////////////////////////

// define the tree-item component
Vue.component("tree-item", {
	template: "#item-template",
	props: {
	  item: Object ,   //these properties can be accessed/modified externally, as well as in computed/methods (refer to it using this.item)
	  depth: Number
	},
	data: function() {  //component instance's initial state is obtained from here, refer to data in methods/computed using this.isOpen
	  return {
		isOpen: false
	  };
	},
	computed: {

	  //can have some additional logic when displaying name (eg. truncating, combining label + detail)
	  getIndent: function() {
		console.log('spacing ',this.depth);
		return (this.depth * 10) + 'px';
	  }
	},
	methods: {
		showCtxMenu: function (event,nodeID) {
			console.log(event,nodeID);
			  contextMenuFor("ctxmenu-div",event,nodeID);
			  //pass the uid to it somehow
		},
//		viewNode: function(e, type, id) {
		viewNode: function(e, id) {
			//view node
			console.log(e,id);
//			v_action_funcs['view'](type,id);
			v_action_funcs['view'](id);
		},
		toggle: function(id) {
			if (this.hasChildren) {
			  if(!this.isOpen) 
				fetchChildNodes(id);
			  this.isOpen = !this.isOpen;
			}
		},
	    hasChildren: function() {
			return this.item.out && this.item.out.length;
		},
		name: function() {
			console.log("name this.item",this.item);
			return this.item[PROP_LABEL];
		},
		makeFolder: function() {
		/*if (!this.hasChildren) {
		  this.$emit("make-folder", this.item);
		  this.isOpen = true;
		}*/
		},
	}
});


// boot up the demo
var v_tree_pane = new Vue({
	el: "#v_tree_pane",
	data: {
	  treeData: G
	},
	methods: {
		makeFolder: function(item) {
			Vue.set(item, "children", []);
			this.addItem(item);
		},
		addItem: function(item) {
			item.children.push({
			  name: "new stuff",
			  children: [] //**added this and now mchild will work for all chidren
		});
	  }
	}
});

function contextMenuFor(ctxmenudiv,event,nodeID)
{
	event.preventDefault();

	let n = _index[nodeID];

	if(n) {
		G.ctxmenuData = emptyCtxMenuData(n[PROP_UID]);

		let nConfig = _typeConfigs[n[PROP_TYPE]] || _typeConfigs['unknown'];

		if(nConfig.actionEditConf)
			G.ctxmenuData.mainOptions.push("edit");
		if(nConfig.actionMoveParentConf)
			G.ctxmenuData.mainOptions.push("moveparent");
		if(nConfig.actionMoveParentConf)
			G.ctxmenuData.mainOptions.push("movechildren");
		
		let allowedToAdd = Array.from(nConfig.typesAllowedForChildNodes || []);
		allowedToAdd.forEach((typename,index) => {G.ctxmenuData.addOptions.push(`+${typename}`)});

		let menu = document.getElementById(ctxmenudiv);
		menu.style.left = event.pageX + 'px';
		menu.style.top = event.pageY + 'px';
		menu.style.display = 'block';

	}
	//nodeID not found, no context menu to show
	return;
}


// {uid:'0x345',mainOptions:['edit','move'],addOptions:['+foo','+bar']}
function emptyCtxMenuData(_uid = '.') {
	return {uid: _uid, mainOptions: [], addOptions: []};
}

//var G.ctxmenuData = emptyCtxMenuData();

var v_action_funcs = { 
	view: async function (uid) { 
		let n = _index[uid];
		let tc = _typeConfigs[(n[PROP_TYPE] || "unknown")] || _typeConfigs.unknown;
		//let tc = _typeConfigs[typename];
		if(tc) {
			let conf =  tc.actionViewConf || _typeConfigs.unknown.actionViewConf;
			_panesIndex.view[conf.paneType].v.config = conf.config;
			_panesIndex.view[conf.paneType].v.config.nodeinfo = _index[uid];
			_panesIndex.view[conf.paneType].onBeforeShow();
			switchPane('view',conf.paneType);
		}
	},
	add: async function (typenameOfNew, _uid) { 
		let tc = _typeConfigs[typenameOfNew];
		if(tc) {
			let conf =  tc.actionAddConf || _typeConfigs.unknown.actionAddConf;
			_panesIndex.add[conf.paneType].v.config = conf.config;
			let newN = emptyNode('',typenameOfNew);
			newN[PROP_PARENTLIST].push({uid: _uid});
			_panesIndex.add[conf.paneType].v.config.nodeinfo = newN;
			_panesIndex.add[conf.paneType].onBeforeShow();
			switchPane('add',conf.paneType);
		}
	},
	edit: async function (uid) { 
		let n = _index[uid];
		let tc = _typeConfigs[(n[PROP_TYPE] || "unknown")] || _typeConfigs.unknown;
		if(tc) {
			let conf =  tc.actionEditConf || _typeConfigs.unknown.actionEditConf;
			_panesIndex.edit[conf.paneType].v.config = conf.config;
			
			if(_panesIndex.edit[conf.paneType].onBeforeCopyNode) {
				_panesIndex.edit[conf.paneType].v.config.nodeinfo = n;
				await _panesIndex.edit[conf.paneType].onBeforeCopyNode();
			}			
			let tmpNodeCopy = emptyNode(n[PROP_UID]);
			tmpNodeCopy[PROP_LABEL] = n[PROP_LABEL] || null;
			tmpNodeCopy[PROP_DETAIL] = n[PROP_DETAIL] || null;
			tmpNodeCopy[PROP_CUSTOM] = n[PROP_CUSTOM] || null;
			tmpNodeCopy[PROP_TEXTDATA] = n[PROP_TEXTDATA] || null;
			tmpNodeCopy[PROP_TIME] = n[PROP_TIME] || null;
			tmpNodeCopy.hasChanged = n.hasChanged;
			_panesIndex.edit[conf.paneType].v.config.nodeinfo = tmpNodeCopy;
			
			_panesIndex.edit[conf.paneType].onBeforeShow();
			switchPane('edit',conf.paneType);
		}
	},
};

var v_ctxmenu = new Vue({
	el: "#v_ctxmenu",
	data: {
	  vdata: G
	},
	methods: {
		ctxmenuAction: function (e, ac, uid) {
			console.log ( "ctxmenuAction: ",ac, uid);
			if(ac.startsWith('+')) {
				v_action_funcs['add'](ac.substring(1),uid);
			}
			else
				v_action_funcs[ac](uid);
		}
	}
});


function handleSubmit(ac, pane) {
	console.log ( "handleSubmit: ",ac, pane);
	_panesIndex[ac][pane].onAfterSubmit();
	if(ac != 'view' && ac != 'edit')
		toggleModal();
}



var v_view_default = new Vue({
	el: '#v_view_default',
	data: { 
	   v: _panesIndex['view']['default'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vCustom :  function(x){ 
			console.log(x);
		}
	}
});

var v_view_download = new Vue({
	el: '#v_view_download',
	data: { 
	   v: _panesIndex['view']['download'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vOpenNewWindow :  function(url){ 
			//console.log(x);
			openNewWindow(url);
		}
	}
});

var v_view_textbody = new Vue({
	el: '#v_view_textbody',
	data: { 
	   v: _panesIndex['view']['textbody'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vCustom :  function(x){ 
			console.log(x);
		}
	}
});

var v_edit_default = new Vue({
	el: '#v_edit_default',
	data: { 
	   v: _panesIndex['edit']['default'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('edit', 'default');
		}
	}
});

var v_add_default = new Vue({
	el: '#v_add_default',
	data: { 
	   v: _panesIndex['add']['default'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'default');
		}
	}
});


var v_add_editor = new Vue({
	el: '#v_add_editor',
	data: { 
	   v: _panesIndex['add']['editor'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'editor');
		}
	}
});

/*
var v_editAndView_editor = new Vue({
	el: '#v_view_editor',
	data: { 
	//FIX THIS: it doesnt work if you click "edit" from the view because _panesIndex['view']['editor'].v is populated
	   v: _panesIndex['edit']['editor'].v
	},
	methods : {
        testEventHandler: function (e,id) {
			console.log(e,id);
        }, 
		vToggleQuill :  function(id){ 
			toggleQuill(id);
		}
	}
});
*/

var v_add_fileupload = new Vue({
	el: '#v_add_fileupload',
	data: { 
	   v: _panesIndex['add']['fileupload'].v,
	   filename: 'No File Selected'
	},
	methods : {
        vUpdateFileName: function () {
			//console.log(e,id);
			const fileInput = document.getElementById("at_file");
			if (fileInput.files.length > 0) {
				const fileName = document.getElementById('at_file_name');
				fileName.textContent = fileInput.files[0].name;
			}
        }, 
		vSubmit :  function(){ 
			handleSubmit('add', 'fileupload');
		}
	}
});

var v_currently_selected_node = { node: G.root };

var vue_topnav = new Vue({
	el: '#v_topnav',
	data: { 
	   v: v_currently_selected_node,
	},
	methods: {
		vShowTasks: function() {
			//showTasks();
		}
	}
});


////////////////////////////////////////////////////
//   draggable pane javascript
////////////////////////////////////////////////////

let isLeftDragging = false;
let isRightDragging = false;

function ResetColumnSizes() {
  // when page resizes return to default col sizes
  let page = document.getElementById("pageFrame");
  page.style.gridTemplateColumns = "2fr 6px 6fr";
}

function SetCursor(cursor) {
  let page = document.getElementById("page");
  page.style.cursor = cursor;
}

function StartLeftDrag() {
  // console.log("mouse down");
  isLeftDragging = true;

  SetCursor("ew-resize");
}

function StartRightDrag() {
  // console.log("mouse down");
  isRightDragging = true;

  SetCursor("ew-resize");
}

function EndDrag() {
  // console.log("mouse up");
  isLeftDragging = false;
  isRightDragging = false;

  SetCursor("auto");
}

function OnDrag(event) {
  if (isLeftDragging || isRightDragging) {

    let page = document.getElementById("page");
    let left_pane = document.getElementById("left_pane");

    let leftPaneWidth = isLeftDragging ? event.clientX : left_pane.clientWidth;

    let dragbarWidth = 6;

    let cols = [
      leftPaneWidth,
      dragbarWidth,
      page.clientWidth - dragbarWidth - leftPaneWidth,
    ];

    let newColDefn = cols.map(c => c.toString() + "px").join(" ");

    page.style.gridTemplateColumns = newColDefn;

    event.preventDefault()
  }
}


////////////////////////////////////////////////////
//   
////////////////////////////////////////////////////



fetchInitialNodes();

</script>

</body></html>
